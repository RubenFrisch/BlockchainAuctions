<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/png" href="favicon.png" sizes="16x16">
  <title>Auction Admin Dashboard</title>

  <style>
    body {
      font-family: 'Helvetica Neue', Arial, sans-serif;
      background-color: #121212;
      color: #f1f1f1;
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding-top: 60px;
      scrollbar-width: thin;
      scrollbar-color: #9c2f2f #1e1e1e;
    }
    
    #app {
      background-color: #1e1e1e;
      border-radius: 10px;
      box-shadow: 0px 4px 20px rgba(0, 0, 0, 0.5);
      padding: 40px;
      width: 1000px;
      text-align: center;
    }
    
    h1 {
      font-size: 40px;
      font-weight: 600;
      color: #ffffff;
      margin-bottom: 20px;
      user-select: none;
    }
    
    button {
      background-color: #333333;
      border: none;
      color: white;
      padding: 12px 20px;
      margin: 10px;
      cursor: pointer;
      border-radius: 5px;
      font-size: 16px;
      transition: background-color 0.3s ease;
    }
    
    button:hover {
      background-color: #4a4a4a;
    }
    
    #disconnectButton {
      background-color: #b63737;
    }
    
    #disconnectButton:hover {
      background-color: #7c2424;
    }
    
    #connectButton {
      background-color: #00ff62;
      color: black;
    }
    
    #connectButton:hover {
      background-color: #00b646;
    }
    
    #adminFunctions {
      margin-top: 20px;
      display: none;
    }

    #auctionFunctions {
      margin-top: 20px;
      display: none;
    }
    
    #walletAddress {
      margin-bottom: 20px;
      font-weight: bold;
      color: #f1f1f1;
      display: none;
    }
    
    .wallet-buttons {
      position: absolute;
      top: 20px;
      right: 20px;
    }
    
    .wallet-buttons button {
      margin-left: 10px;
    }
    
    .wallet-display {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 14px;
      font-weight: bold;
      color: #ffffff;
      background-color: transparent;
      padding: 5px;
      margin: 0;
      border: none;
      user-select: none;
      box-shadow: none;
    }
    
    #networkContainer {
      top: 40px;
    }
    
    .wallet-buttons {
      position: absolute;
      top: 1px;
      right: 1px;
      font-size: 15px;
      font-weight: bold;
      color: #333;
      background-color: transparent;
      padding: 0;
      margin: 0;
      border: none;
      box-shadow: none;
    }
    
    .admin-action-button {
      background-color: #333333;
      border: 1px solid #555555;
      color: #f1f1f1;
      padding: 12px 20px;
      border-radius: 5px;
      font-size: 14px;
      transition: all 0.3s ease;
      margin: 8px 0;
    }
    
    .admin-action-button:hover {
      background-color: #1b1b1b;
    }
    
    .admin-action-input {
      background-color: #333333;
      border: 1px solid #555555;
      color: #f1f1f1;
      padding: 12px 20px;
      border-radius: 5px;
      font-size: 14px;
      transition: all 0.3s ease;
      margin: 8px 0;
    }
    
    .admin-action-input:hover {
      background-color: #1b1b1b;
    }
    
    .result-box {
      padding: 10px;
      font-size: 14px;
      border: 1px solid #555555;
      border-radius: 5px;
      margin-left: 10px;
      display: inline-block;
      min-width: 50px;
      text-align: center;
      background-color: #222222;
      color: #f1f1f1;
      transition: border 0.3s ease-in-out;
    }
    
    .result-box:hover {
      background-color: #000000;
      border: 1px solid orange;
    }
    
    .greenPause-button {
      background-color: #9c2f2f;
      border: none;
      color: white;
    }
    
    .greenPause-button:hover {
      background-color: #631d1d;
    }
    
    .redPause-button {
      background-color: #9c2f2f;
      border: none;
      color: white;
    }
    
    .redPause-button:hover {
      background-color: #631d1d;
    }
    
    .functionality-group {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      margin-top: 60px;
      padding: 20px;
      border: 1px solid #747474;
      transition: border 0.3s ease-in-out;
      border-radius: 10px;
      background-color: #1e1e1e;
      text-align: center;
    }
    
    .functionality-group h2 {
      text-align: center;
      font-size: 26px;
      margin-bottom: 40px;
      color: #ffffff;
      user-select: none;
    }

    .functionality-group h3 {
      text-align: center;
      font-size: 18px;
      margin-bottom: 20px;
      color: #ffffff;
      user-select: none;
      border-top: 1px solid #4b4b4b;
      padding-top: 15px;
      width: 100%;
      display: inline-block;
    }

    .functionality-group button {
      display: inline-block;
      margin-bottom: 10px;
    }
    
    .functionality-group:hover {
      border: 1px solid orange;
    }
    
    #timelockStartQueueButton {
      background-color: #9c2f2f;
    }
    
    #timelockStartQueueButton:hover {
      background-color: #631d1d;
    }
    
    #multiSigRegisterSignatureButton {
      background-color: #9c2f2f;
    }
    
    #multiSigRegisterSignatureButton:hover {
      background-color: #631d1d;
    }
    
    #startRenounceProcessButton {
      background-color: #9c2f2f;
    }
    
    #startRenounceProcessButton:hover {
      background-color: #631d1d;
    }
    
    #terminateRenounceProcessButton {
      background-color: #9c2f2f;
    }
    
    #terminateRenounceProcessButton:hover {
      background-color: #631d1d;
    }
    
    #renounceOwnershipButton {
      background-color: #9c2f2f;
    }
    
    #renounceOwnershipButton:hover {
      background-color: #631d1d;
    }
    
    #transferOwnershipButton {
      background-color: #9c2f2f;
    }
    
    #transferOwnershipButton:hover {
      background-color: #631d1d;
    }
    
    #acceptOwnershipButton {
      background-color: #9c2f2f;
    }
    
    #acceptOwnershipButton:hover {
      background-color: #631d1d;
    }
    
    #resetPendingOwnerButton {
      background-color: #9c2f2f;
    }

    #resetPendingOwnerButton:hover {
      background-color: #631d1d;
    }

    #socialGuardianRecoveryButton {
      background-color: #9c2f2f;
    }

    #socialGuardianRecoveryButton:hover {
      background-color: #631d1d;
    }

    .pause-status-container,
    .pause-control-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      width: 100%;
      padding-left: 15px;
      padding-right: 15px;
      box-sizing: border-box;
    }
    
    .pause-buttons-container {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      margin-bottom: 20px;
    }
    
    .pause-feedback-container,
    .aligned-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      width: 100%;
      padding-left: 15px;
      padding-right: 15px;
      box-sizing: border-box;
    }
    
    #pauseFeedback_ON,
    #pauseFeedback_OFF,
    #pauseStatus {
      user-select: none;
    }
    
    .aligned-container button,
    .aligned-container input {
      margin-right: 5px;
      text-align: left;
    }
    
    #pauseFeedback_ON:hover,
    #pauseFeedback_OFF:hover {
      background-color: #000000;
      border: 1px solid orange;
    }
    
    #networkName {
      display: none;
    }
    
    #errorLog {
      position: absolute;
      top: 70px;
      left: 10px;
      font-size: 16px;
      margin-top: 20px;
      margin-left: 10px;
      background-color: #ffdddd;
      border: 1px solid red;
      border-radius: 5px;
      padding: 10px;
      width: 675px;
    }
    
    #errorLog h3 {
      color: red;
      margin: 0;
      padding-bottom: 16px;
    }
    
    #errorMessages li {
      color: #d8000c;
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .signer-list {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      background-color: #2b2b2b;
      border-radius: 10px;
      color: #fff;
      max-width: 500px;
      margin-bottom: 30px;
    }
    
    .signer-item {
      margin-bottom: 10px;
      padding: 10px;
      background-color: #333;
      border-radius: 5px;
      font-family: monospace;
      white-space: nowrap;
      overflow: hidden;
      text-align: center;
      text-overflow: ellipsis;
    }
    
    .signer-item:hover {
      background-color: #444;
    }
    
    .circuitBreakerFunctionalityGroup .result-box {
      width: 300px;
      text-align: center;
    }
    
    .circuitBreakerFunctionalityGroup .admin-action-button {
      width: 250px;
      text-align: center;
    }
    
    .ownershipControlFunctionalityGroup .result-box {
      width: 350px;
      text-align: center;
    }
    
    .ownershipControlFunctionalityGroup .admin-action-button {
      width: 250px;
      text-align: center;
    }
    
    .timelockGuardFunctionalityGroup .result-box {
      width: 200px;
      text-align: center;
    }
    
    .timelockGuardFunctionalityGroup .admin-action-button {
      width: 275px;
      text-align: center;
    }
    
    .multiSignatureFunctionalityGroup .result-box {
      width: 200px;
      text-align: center;
    }
    
    .multiSignatureFunctionalityGroup .admin-action-button {
      width: 400px;
      text-align: center;
    }
    
    #multiSigSignerInput {
      width: 175px;
      text-align: center;
    }
    
    #multiSigHasSignedInput {
      width: 175px;
      text-align: center;
    }
    
    #transferOwnershipInput {
      text-align: center;
    }

    #socialGuardianRecoveryInput {
      text-align: center;
    }

    #mintNFTAddressInput {
      text-align: center;
      width: 185px;
    }

    #mintNFTURIInput {
      text-align: center;
      width: 100px;
    }

    .nftFunctionalityGroup .result-box {
      width: 275px;
      text-align: center;
    }

    .nftFunctionalityGroup .admin-action-button {
      width: 250px;
      text-align: center;
    }
    
    #balanceOfNFTInput {
      text-align: center;
      width: 200px;
    }

    #ownerOfNFTInput {
      text-align: center;
      width: 200px;
    }

    #mintNFTButton {
      width: 100px;
    }

    #approveNFTButton {
      width: 137px;
    }

    #tokenURINFTInput {
      text-align: center;
      width: 200px;
    }

    #burnNFTInput {
      text-align: center;
      width: 200px;
    }

    #approveNFTInputID {
      text-align: center;
      width: 45px;
    }

    #approveNFTInputAddress, #getApprovedNFTInput, #setApprovalForAllNFTInput, #resetApprovalNFTInput, #resetApprovalForAllNFTInput {
      text-align: center;
      width: 200px;
    }

    #checkApprovalForAllNFTInputOwnerAddress, #checkApprovalForAllNFTInputOperatorAddress {
      text-align: center;
      width: 100px;
    }

    #ownerOfNFTSpan, #balanceOfNFTSpan, #tokenURINFTSpan, #burnNFTSpan, #approveNFTSpan, #getApprovedNFTSpan, #mintNFTSpan, #setApprovalForAllNFTSpan, #resetApprovalNFTSpan, #resetApprovalForAllNFTSpan {
      width: 350px;
    }

    #checkApprovalForAllNFTSpan {
      word-wrap: break-word;
      white-space: normal;
      max-width: 275px;
      width: 275px;
    }

    #nftCollectionNameLabel, #nftCollectionNameSpan, #nftCollectionSymbolLabel, #nftCollectionSymbolSpan  {
      margin-bottom: 10px;
      margin-right: 10px;
      text-align: center;
      border-width: 0;
      user-select: none;
    }

    #auctionID, #auctionStartBlock, #auctionEndBlock, #startingPrice, #bidIncrement, #reservePrice, #auctionSnipeInterval, #auctionSnipeBlocks, #nftContractAddress, #nftTokenID, #ipfsString {
      text-align: center;
      border-width: 0;
      user-select: none;
      width: 200px;
    }

    .auctionRegistrationFunctionalityGroup .result-box {
      width: 275px;
      text-align: center;
    }

    .auctionRegistrationFunctionalityGroup .admin-action-input {
      width: 335px;
      text-align: center;
    }

    #latestBlockNumber {
      margin-bottom: 10px;
      margin-right: 10px;
      text-align: center;
      border-width: 0;
      user-select: none;
      width: 300px;
    }

    #latestBlockNumberSpan {
      margin-bottom: 10px;
      margin-right: 10px;
      text-align: center;
      border-width: 0;
      user-select: none;
      width: 200px;
    }

    #nftCollectionNameSpan, #nftCollectionSymbolSpan {
      width: 200px;
    }

    #transferNFTInputFROM, #transferNFTInputTO {
      text-align: center;
      width: 170px;
    }

    #transferNFTInputTokenID {
      text-align: center;
      width: 45px;
    }

    #transferNFTSpan {
      width: 150px;
    }

    #transferNFTButton {
      width: 125px;
    }

    #refreshButton {
      position: absolute;
      background: url('refresh.png') no-repeat center;
      background-size: contain;
      top: 60px;
      left: 1755px;
      background-color: transparent;
      width: 35px;
      height: 35px;
      border: none;
      padding: 8px 12px;
      font-size: 30px;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s ease;
      display: none;
    }
    
    #refreshButton:hover {
      background: url('refresh_hover.png') no-repeat center;
      background-size: contain;
    }
    
    #refreshButton img {
      width: 35px;
      height: 35px;
    }
    
    .footer {
      background-color: #1e1e1e;
      color: #d3d3d3;
      padding: 20px;
      text-align: center;
      font-size: 14px;
      border-top: 1px solid #333;
      position: relative;
      margin-top: 50px;
      border-radius: 10px;
      line-height: 1.8;
    }
    
    .footer strong {
      color: #ffffff;
    }
    
    .footer p {
      margin: 5px 0;
    }
    
    footer a {
        color: #ff9800;
    }
    
    footer a:hover {
        color: #3846ff;
    }
    
    footer a:active{
        color: #939bff;
    }

    #metamaskHeader2{
      color: #00ff62;
      display: block;
    }
    
    #toggleButton {
      display: none;
      justify-content: center;
      align-items: center;
    }

    .toggle-button-container {
      display: flex;
      justify-content: center;
      align-items: center;
    }

    ::-webkit-scrollbar {
      width: 10px;
    }

    ::-webkit-scrollbar-track {
      background: #1e1e1e;
    }

    ::-webkit-scrollbar-thumb {
      background-color: #9c2f2f;
      border-radius: 10px;
      border: 2px solid #1e1e1e;
    }

    ::-webkit-scrollbar-thumb:hover {
      background-color: #9c2f2f;
    }

    * {
      scrollbar-width: thin;
      scrollbar-color: #9c2f2f #1e1e1e;
    }


    .custom-slider {
      -webkit-appearance: none;
      width: 25%;
      height: 8px;
      background: linear-gradient(90deg, #ffe055, #ff6060);
      border-radius: 5px;
      outline: none;
      transition: background 0.3s ease;
      margin: 20px 0;
    }

    .custom-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        background-color: #a5a5a5;
        border: 2px solid #a5a5a5;
        border-radius: 50%;
        cursor: pointer;
        transition: transform 0.2s ease;
    }

    .custom-slider::-webkit-slider-thumb:hover {
        transform: scale(1.2);
    }

    .custom-slider::-moz-range-thumb {
        width: 20px;
        height: 20px;
        background-color: #ffffff;
        border: 2px solid #000000;
        border-radius: 50%;
        cursor: pointer;
        transition: transform 0.2s ease;
    }

    .custom-slider::-moz-range-thumb:hover {
        transform: scale(1.2);
    }

    .custom-slider:active::-webkit-slider-thumb {
        transform: scale(1.3);
        background-color: #616161;
        border: 2px solid #616161;
    }

    #auctionStartBlockErrorSpan, #auctionEndBlockErrorSpan, #auctionSnipeIntervalErrorSpan, #auctionSnipeBlocksErrorSpan, #nftContractAddressErrorSpan, #nftTokenIDErrorSpan, #ipfsStringErrorSpan, #auctionIDErrorSpan {
      user-select: none;
      color: red;
      border: 0px;
      background-color: transparent;
      width: 275px;
    }

    #validityCheckErrorSpan {
      user-select: none;
      color: red;
      border: 0px;
      background-color: transparent;
      width: 400px;
      text-align: center;
    }

    #registerAuctionErrorSpan {
      color: red;
      border: 0px;
      background-color: transparent;
      width: 800px;
      text-align: center;
    }

    #startingPriceErrorSpan, #bidIncrementErrorSpan, #reservePriceErrorSpan {
      user-select: none;
      color: red;
      border: 0px;
      background-color: transparent;
      width: 150px;
    }

    .mandatory_field_asterisk_styleTarget {
      color: red;
    }

    .auctionWhitelistFunctionalityGroup .result-box {
      width: 300px;
      text-align: center;
    }

    .auctionBlacklistFunctionalityGroup .result-box {
      width: 300px;
      text-align: center;
    }

    .auctionCancellableFunctionalityGroup .result-box {
      width: 300px;
      text-align: center;
    }

    .auctionEntryFeeFunctionalityGroup .result-box {
      width: 300px;
      text-align: center;
    }

    .auctionQueryToolFunctionalityGroup .result-box {
      width: 400px;
      text-align: center;
    }

    .auctionWhitelistFunctionalityGroup .admin-action-input {
      width: 275px;
      text-align: center;
    }

    .auctionBlacklistFunctionalityGroup .admin-action-input {
      width: 275px;
      text-align: center;
    }

    .auctionCancellableFunctionalityGroup .admin-action-input {
      width: 275px;
      text-align: center;
    }

    .auctionEntryFeeFunctionalityGroup .admin-action-input {
      width: 275px;
      text-align: center;
    }

    .auctionQueryToolFunctionalityGroup .admin-action-input {
      width: 150px;
      text-align: center;
    }

    .auctionWhitelistFunctionalityGroup .admin-action-button {
      width: 225px;
      text-align: center;
    }

    .auctionBlacklistFunctionalityGroup .admin-action-button {
      width: 225px;
      text-align: center;
    }

    .auctionCancellableFunctionalityGroup .admin-action-button {
      width: 225px;
      text-align: center;
    }

    .auctionEntryFeeFunctionalityGroup .admin-action-button {
      width: 225px;
      text-align: center;
    }

    .auctionQueryToolFunctionalityGroup .admin-action-button {
      width: 225px;
      text-align: center;
    }

    #whitelistAuctionParticipantCheckInputAuctionID, #whitelistAuctionParticipantCheckInputAddress,
    #blacklistAuctionParticipantCheckInputAuctionID, #blacklistAuctionParticipantCheckInputAddress,
    #hasPaidEntryFeeInputAuctionID, #hasPaidEntryFeeInputParticipantAddress,
    #hasWithdrawnEntryFeeInputAuctionID, #hasWithdrawnEntryFeeInputParticipantAddress,
    #setEntryFeeInputAuctionID, #setEntryFeeInputEntryFeeAmountEther
    {
      width: 100px;
    }

    #whitelistParticipantsInput, #blacklistParticipantsInput {
      width: 35%;
      height: 120px;
      padding: 10px;
      font-size: 11px;
      font-family: inherit;
      background-color: #2a2a2a;
      color: #f5f5f5;
      border: 1px solid #444;
      border-radius: 5px;
      resize: none;
      box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
    }

    #whitelistParticipantsInputAuctionID, #blacklistParticipantsInputAuctionID {
      width: 100px;
    }

    #whitelistParticipantsSpan, #blacklistParticipantsSpan {
      width: 100px;
    }

    </style>
</head>
<body>
  
  <div id="app">

    <h1>Auction Admin Dashboard</h1>
    <h2 id="metamaskHeader2"> Connect Metamask Wallet to Begin</h2>

    <button id="refreshButton" class="refresh-button"></button>

    <div class="wallet-buttons">
      <button id="connectButton" style="display: block;">Connect Wallet</button>
      <button id="disconnectButton" style="display: none;">Disconnect Wallet</button>
    </div>

    <div id="errorLog"
      style="margin-top: 20px; border: 1px solid red; padding: 10px; background-color: #fdd; display: none;">
      <h3>Error Log</h3>
      <ul id="errorMessages" style="list-style: none; padding: 0;"></ul>
    </div>

    <div class="toggle-button-container">
      <div>
        <button class="admin-action-button" id="toggleButton">Show Auction Functions</button>
      </div>
    </div>


    <div id="walletAddressContainer" class="wallet-display">
      <span id="walletAddress">Wallet: Not Connected</span>
    </div>

    <div id="networkContainer" class="wallet-display">
      <span id="networkName">Connected Network: Unknown</span>
    </div>

    <div id="adminFunctions">

      <!-- Pause -->
      <div class="functionality-group circuitBreakerFunctionalityGroup">
        <h2>Circuit Breaker Control Panel</h2>

        <div class="pause-status-container">
          <button class="admin-action-button" id="checkPauseButton">Check System Pause Status</button>
          <span class="result-box" id="pauseStatus">-</span>
        </div>

        <!-- Emergency Pause ON + Feedback -->
        <div class="pause-control-container">
          <button class="admin-action-button greenPause-button" id="turnPauseOnButton">Turn Emergency Pause ON</button>
          <span class="result-box" id="pauseFeedback_ON">-</span>
        </div>

        <!-- Emergency Pause OFF + Feedback -->
        <div class="pause-control-container">
          <button class="admin-action-button redPause-button" id="turnPauseOffButton">Turn Emergency Pause OFF</button>
          <span class="result-box" id="pauseFeedback_OFF">-</span>
        </div>

      </div>

      <!-- Ownership -->
      <div class="functionality-group ownershipControlFunctionalityGroup">
        <h2>Ownership Control Panel</h2>

        <div class="aligned-container">
          <button class="admin-action-button" id="checkCurrentOwnerButton">Current Owner</button>
          <span class="result-box" id="currentOwner">-</span>
        </div>

        <div class="aligned-container">
          <button class="admin-action-button" id="checkPendingOwnerButton">Pending Owner</button>
          <span class="result-box" id="pendingOwner">-</span>
        </div>

        <div class="aligned-container">
          <button class="admin-action-button renounce-button" id="checkRenounceUnlockedStatusButton">Renounce Unlocked Status</button>
          <span class="result-box" id="renounceUnlockedStatus">-</span>
        </div>

        <div class="aligned-container">
          <button class="admin-action-button" id="startRenounceProcessButton">Initiate Renounce Process</button>
          <span class="result-box" id="startRenounceProcessSpan">-</span>
        </div>

        <div class="aligned-container">
          <button class="admin-action-button" id="terminateRenounceProcessButton">Terminate Renounce Process</button>
          <span class="result-box" id="terminateRenounceProcessSpan">-</span>
        </div>

        <div class="aligned-container">
          <button class="admin-action-button" id="renounceOwnershipButton">Complete Renounce Process</button>
          <span class="result-box" id="renounceOwnershipSpan">-</span>
        </div>

        <div class="aligned-container">
          <button class="admin-action-button" id="transferOwnershipButton">Transfer Ownership</button>
          <input type="text" class="admin-action-input" id="transferOwnershipInput" placeholder="Enter Address" />
          <span class="result-box" id="transferOwnershipSpan">-</span>
        </div>

        <div class="aligned-container">
          <button class="admin-action-button" id="acceptOwnershipButton">Accept Ownership</button>
          <span class="result-box" id="acceptOwnershipSpan">-</span>
        </div>

        <div class="aligned-container">
          <button class="admin-action-button" id="resetPendingOwnerButton">Reset Pending Owner</button>
          <span class="result-box" id="resetPendingOwnerSpan">-</span>
        </div>

        <div class="aligned-container">
          <button class="admin-action-button" id="socialGuardianRecoveryButton">Initiate Social Guardian Recovery</button>
          <input type="text" class="admin-action-input" id="socialGuardianRecoveryInput" placeholder="Enter Address" />
          <span class="result-box" id="socialGuardianRecoverySpan">-</span>
        </div>

      </div>

      <!-- Timelock -->
      <div class="functionality-group timelockGuardFunctionalityGroup">
        <h2>Timelock Guard Control Panel</h2>

        <div class="aligned-container">
          <button class="admin-action-button timelockDelay" id="_DELAY">Timelock Guard - Delay</button>
          <span class="result-box" id="timelockDelay">10 minutes</span>
        </div>

        <div class="aligned-container">
          <button class="admin-action-button timelockGracePeriod" id="_GRACE_PERIOD">Timelock Guard - Grace
            period</button>
          <span class="result-box" id="timelockDelay">5 minutes</span>
        </div>

        <div class="aligned-container">
          <button class="admin-action-button timelockQueueTime" id="queueTimeButton">Timelock Guard - Queue
            time</button>
          <span class="result-box" id="queueTime">-</span>
        </div>

        <div class="aligned-container">
          <button class="admin-action-button timelockCountdown" id="timelockCountdownButton">Timelock Guard - Countdown
            end</button>
          <span class="result-box" id="timelockCountdown">-</span>
        </div>

        <div class="aligned-container">
          <button class="admin-action-button" id="timelockStartQueueButton">Timelock Guard - Start queue</button>
          <span class="result-box" id="timelockStartQueue">-</span>
        </div>

      </div>

      <!-- Multi Signature -->
      <div class="functionality-group multiSignatureFunctionalityGroup">
        <h2>Multi Signature Guard Control Panel</h2>

        <div id="signerList" class="signer-list"></div>

        <div class="aligned-container">
          <button class="admin-action-button" id="multiSigTotalSignersButton">Multi Signature Guard - Total
            Signers</button>
          <span class="result-box" id="multiSigTotalSigners">7 signers</span>
        </div>

        <div class="aligned-container">
          <button class="admin-action-button" id="multiSigRequiredSignaturesButton">Multi Signature Guard - Signature
            Threshold</button>
          <span class="result-box" id="multiSigRequiredSignatures">5 signatures</span>
        </div>

        <div class="aligned-container">
          <button class="admin-action-button" id="multiSigValidityTimeButton">Multi Signature Guard - Signature Validity
            Time</button>
          <span class="result-box" id="multiSigValidityTime">15 minutes</span>
        </div>

        <div class="aligned-container">
          <button class="admin-action-button" id="multiSigExpiryTimeButton">Multi Signature Guard - Signature Expiration
            Time</button>
          <span class="result-box" id="multiSigExpiryTime">-</span>
        </div>

        <div class="aligned-container">
          <button class="admin-action-button" id="multiSigCurrentSignatureCountButton">Multi Signature Guard - Current
            Signature Count</button>
          <span class="result-box" id="multiSigCurrentSignatureCount">-</span>
        </div>

        <div class="aligned-container">
          <button class="admin-action-button" id="multiSigCheckSignerButton">Multi Signature Guard - Check if address is
            Signer</button>
          <input type="text" class="admin-action-input" id="multiSigSignerInput" placeholder="Enter Address" />
          <span class="result-box" id="multiSigCheckSigner">-</span>
        </div>

        <div class="aligned-container">
          <button class="admin-action-button" id="multiSigHasSignedButton">Multi Signature Guard - Check if address has
            signed</button>
          <input type="text" class="admin-action-input" id="multiSigHasSignedInput" placeholder="Enter Address" />
          <span class="result-box" id="multiSigHasSigned">-</span>
        </div>

        <div class="aligned-container">
          <button class="admin-action-button" id="multiSigRegisterSignatureButton">Multi Signature Guard - Register
            signature</button>
          <span class="result-box" id="multiSigRegisterSignatureSpan">-</span>
        </div>
      </div>

    </div>

    <div id="auctionFunctions">
    
      <!-- NFT functions -->
      <div class="functionality-group nftFunctionalityGroup">
        <h2>NFT Control Panel</h2>

        <div class="aligned-container">
          <span class="result-box" id="nftCollectionNameLabel">NFT Collection's Name:</span>
          <span class="result-box" id="nftCollectionNameSpan">-</span>
          <span class="result-box" id="nftCollectionSymbolLabel">NFT Collection's Symbol:</span>
          <span class="result-box" id="nftCollectionSymbolSpan">-</span>
        </div>

        <h3>Mint NFT</h3>

        <div class="aligned-container">
          <button class="admin-action-button" id="mintNFTButton">Mint NFT</button>
          <input type="text" class="admin-action-input" id="mintNFTAddressInput"
            placeholder="Enter NFT Recipient Address" />
          <input type="text" class="admin-action-input" id="mintNFTURIInput" placeholder="Enter NFT URI" />
          <span class="result-box" id="mintNFTSpan">-</span>
        </div>
    
        <h3>Check NFT State</h3>

        <div class="aligned-container">
          <button class="admin-action-button" id="balanceOfNFTButton">Check NFT Balance of Address</button>
          <input type="text" class="admin-action-input" id="balanceOfNFTInput" placeholder="Enter Address" />
          <span class="result-box" id="balanceOfNFTSpan">-</span>
        </div>
    
        <div class="aligned-container">
          <button class="admin-action-button" id="ownerOfNFTButton">Check Owner of an NFT</button>
          <input type="text" class="admin-action-input" id="ownerOfNFTInput" placeholder="Enter NFT ID number" />
          <span class="result-box" id="ownerOfNFTSpan">-</span>
        </div>

        <div class="aligned-container">
          <button class="admin-action-button" id="tokenURINFTButton">Check URI Metadata of an NFT</button>
          <input type="text" class="admin-action-input" id="tokenURINFTInput" placeholder="Enter NFT ID number" />
          <span class="result-box" id="tokenURINFTSpan">-</span>
        </div>

        <h3>Burn NFT</h3>

        <div class="aligned-container">
          <button class="admin-action-button" id="burnNFTButton">Burn (Destroy) an NFT</button>
          <input type="text" class="admin-action-input" id="burnNFTInput" placeholder="Enter NFT ID number" />
          <span class="result-box" id="burnNFTSpan">-</span>
        </div>
    
        <h3>Single Approval</h3>

        <div class="aligned-container">
          <button class="admin-action-button" id="approveNFTButton">Approve NFT</button>
          <input type="text" class="admin-action-input" id="approveNFTInputID" placeholder="NFT ID" />
          <input type="text" class="admin-action-input" id="approveNFTInputAddress" placeholder="Enter Address for Approval" />
          <span class="result-box" id="approveNFTSpan">-</span>
        </div>

        <div class="aligned-container">
          <button class="admin-action-button" id="getApprovedNFTButton">Get Approved Address</button>
          <input type="text" class="admin-action-input" id="getApprovedNFTInput" placeholder="Enter NFT ID number" />
          <span class="result-box" id="getApprovedNFTSpan">-</span>
        </div>

        <div class="aligned-container">
          <button class="admin-action-button" id="resetApprovalNFTButton">Reset Approval for an NFT</button>
          <input type="text" class="admin-action-input" id="resetApprovalNFTInput" placeholder="Enter NFT ID number" />
          <span class="result-box" id="resetApprovalNFTSpan">-</span>
        </div>

        <h3>Operator Approval</h3>

        <div class="aligned-container">
          <button class="admin-action-button" id="setApprovalForAllNFTButton">Set Approval for All NFTs</button>
          <input type="text" class="admin-action-input" id="setApprovalForAllNFTInput" placeholder="Enter Operator Address" />
          <span class="result-box" id="setApprovalForAllNFTSpan">-</span>
        </div>

        <div class="aligned-container">
          <button class="admin-action-button" id="checkApprovalForAllNFTButton">Check Approval for All NFTs</button>
          <input type="text" class="admin-action-input" id="checkApprovalForAllNFTInputOwnerAddress" placeholder="Enter Owner" />
          <input type="text" class="admin-action-input" id="checkApprovalForAllNFTInputOperatorAddress" placeholder="Enter Operator" />
          <span class="result-box" id="checkApprovalForAllNFTSpan">-</span>
        </div>

        <div class="aligned-container">
          <button class="admin-action-button" id="resetApprovalForAllNFTButton">Revoke Approval for All NFTs</button>
          <input type="text" class="admin-action-input" id="resetApprovalForAllNFTInput" placeholder="Enter Operator Address" />
          <span class="result-box" id="resetApprovalForAllNFTSpan">-</span>
        </div>

        <h3>Transfer NFT</h3>
        <div class="aligned-container">
          <button class="admin-action-button" id="transferNFTButton">Transfer NFT</button>
          <input type="text" class="admin-action-input" id="transferNFTInputFROM" placeholder="Source Address" />
          <input type="text" class="admin-action-input" id="transferNFTInputTO" placeholder="Recipient Address" />
          <input type="text" class="admin-action-input" id="transferNFTInputTokenID" placeholder="NFT ID" />
          <span class="result-box" id="transferNFTSpan">-</span>
        </div>

      </div>

      <!-- Auction Registration Function -->
      <div class="functionality-group auctionRegistrationFunctionalityGroup">
        <h2>Auction Registration Panel</h2>

        <div class="aligned-container">
          <span class="result-box" id="latestBlockNumber">Latest Block Number:</span>
          <span class="result-box" id="latestBlockNumberSpan">-</span>
        </div>

        <h3>Auction ID Parameter</h3>

        <div class="aligned-container">
          <span class="result-box" id="auctionID">Auction ID hash <span class="mandatory_field_asterisk_styleTarget">*</span></span>
          <span class="result-box" id="auctionIDErrorSpan"></span>
          <input type="text" class="admin-action-input" id="auctionIDInput" placeholder="Enter auction ID hash" />
        </div>

        <h3>Duration Parameters</h3>

        <div class="aligned-container">
          <span class="result-box" id="auctionStartBlock">Start Block <span class="mandatory_field_asterisk_styleTarget">*</span></span>
          <span class="result-box" id="auctionStartBlockErrorSpan"></span>
          <input type="text" class="admin-action-input" id="auctionStartBlockInput" placeholder="Enter Start Block Number" />
        </div>

        <div class="aligned-container">
          <span class="result-box" id="auctionEndBlock">End Block <span class="mandatory_field_asterisk_styleTarget">*</span></span>
          <span class="result-box" id="auctionEndBlockErrorSpan"></span>
          <input type="text" class="admin-action-input" id="auctionEndBlockInput" placeholder="Enter End Block Number" />
        </div>

        <h3>Price Parameters</h3>

        <div class="aligned-container">
          <span class="result-box" id="startingPrice">Starting Price (Ether) <span class="mandatory_field_asterisk_styleTarget">*</span></span>
          <input type="range" class="custom-slider" id="startingPriceSlider" min="0.00" max="10" value="0.00" step="0.05" />
          <span class="result-box" id="startingPriceErrorSpan"></span>
          <input type="text" class="admin-action-input" id="startingPriceInput" placeholder="Enter Starting Price" />
        </div>

        <div class="aligned-container">
          <span class="result-box" id="bidIncrement">Bid Increment (Ether) <span class="mandatory_field_asterisk_styleTarget">*</span></span>
          <input type="range" class="custom-slider" id="bidIncrementSlider" min="0.00" max="1" value="0.00" step="0.01" />
          <span class="result-box" id="bidIncrementErrorSpan"></span>
          <input type="text" class="admin-action-input" id="bidIncrementInput" placeholder="Enter Bid Increment" />
        </div>

        <div class="aligned-container">
          <span class="result-box" id="reservePrice">Reserve Price (Ether) <span class="mandatory_field_asterisk_styleTarget">*</span></span>
          <input type="range" class="custom-slider" id="reservePriceSlider" min="0.00" max="10" value="0.00" step="0.05" />
          <span class="result-box" id="reservePriceErrorSpan"></span>
          <input type="text" class="admin-action-input" id="reservePriceInput" placeholder="Enter Reserve Price" />
        </div>

        <h3>Snipe Prevention Parameters</h3>

        <div class="aligned-container">
          <span class="result-box" id="auctionSnipeInterval">Snipe Prevention Interval <span class="mandatory_field_asterisk_styleTarget">*</span></span>
          <span class="result-box" id="auctionSnipeIntervalErrorSpan"></span>
          <input type="text" class="admin-action-input" id="auctionSnipeIntervalInput" placeholder="Enter Snipe Prevention Interval" />
        </div>

        <div class="aligned-container">
          <span class="result-box" id="auctionSnipeBlocks">Snipe Prevention Blocks <span class="mandatory_field_asterisk_styleTarget">*</span></span>
          <span class="result-box" id="auctionSnipeBlocksErrorSpan"></span>
          <input type="text" class="admin-action-input" id="auctionSnipeBlocksInput" placeholder="Enter Snipe Prevention Blocks" />
        </div>

        <h3>NFT Parameters</h3>

        <div class="aligned-container">
          <span class="result-box" id="nftContractAddress">NFT Contract Address <span class="mandatory_field_asterisk_styleTarget">*</span></span>
          <span class="result-box" id="nftContractAddressErrorSpan"></span>
          <input type="text" class="admin-action-input" id="nftContractAddressInput" placeholder="Enter NFT Contract Address" />
        </div>

        <div class="aligned-container">
          <span class="result-box" id="nftTokenID">NFT Token ID <span class="mandatory_field_asterisk_styleTarget">*</span></span>
          <span class="result-box" id="nftTokenIDErrorSpan"></span>
          <input type="text" class="admin-action-input" id="nftTokenIDInput" placeholder="Enter NFT Token ID" />
        </div>

        <h3>IPFS Metadata Parameter</h3>

        <div class="aligned-container">
          <span class="result-box" id="ipfsString">IPFS Metadata</span>
          <span class="result-box" id="ipfsStringErrorSpan"></span>
          <input type="text" class="admin-action-input" id="ipfsStringInput" placeholder="Enter IPFS Metadata" />
        </div>

        <h3></h3>

        <span class="result-box" id="validityCheckErrorSpan"></span>
        <button class="admin-action-button" id="registerAuctionButton">Register Auction</button>
        <span class="result-box" id="registerAuctionErrorSpan"></span>

      </div>

      <!-- Auction Query Tool-->
      <div class="functionality-group auctionQueryToolFunctionalityGroup">
        
        <h2>Auction Query Tool</h2>
      
        <div class="aligned-container">
          <button class="admin-action-button" id="queryAuctionButton">Fetch Auction Properties</button>
          <input type="text" class="admin-action-input" id="queryAuctionInput" placeholder="Enter Auction ID"/>
          <span class="result-box" id="queryAuctionSpan">-</span>
        </div>
      
        <div class="aligned-container">
          <span class="result-box" id="auctionQueryStartBlock">Start Block Number</span>
          <span class="result-box" id="auctionQueryResultStartBlock">-</span>
        </div>
      
        <div class="aligned-container">
          <span class="result-box" id="auctionQueryEndBlock">End Block Number</span>
          <span class="result-box" id="auctionQueryResultEndBlock">-</span>
        </div>
      
        <div class="aligned-container">
          <span class="result-box" id="auctionQueryStartingPrice">Starting Price (Ether)</span>
          <span class="result-box" id="auctionQueryResultStartingPrice">-</span>
        </div>
      
        <div class="aligned-container">
          <span class="result-box" id="auctionQueryBidIncrement">Bid Increment (Ether)</span>
          <span class="result-box" id="auctionQueryResultBidIncrement">-</span>
        </div>

        <div class="aligned-container">
          <span class="result-box" id="auctionQueryReservePrice">Reserve Price (Ether)</span>
          <span class="result-box" id="auctionQueryResultReservePrice">-</span>
        </div>

        <div class="aligned-container">
          <span class="result-box" id="auctionQuerySnipeInterval">Snipe Prevention Block Interval</span>
          <span class="result-box" id="auctionQueryResultSnipeInterval">-</span>
        </div>

        <div class="aligned-container">
          <span class="result-box" id="auctionQuerySnipeBlocks">Snipe Prevention Block Increment</span>
          <span class="result-box" id="auctionQueryResultSnipeBlocks">-</span>
        </div>

        <div class="aligned-container">
          <span class="result-box" id="auctionQueryNFTContractAddress">NFT Contract Address</span>
          <span class="result-box" id="auctionQueryResultNFTContractAddress">-</span>
        </div>

        <div class="aligned-container">
          <span class="result-box" id="auctionQueryNFTTokenID">NFT Token ID</span>
          <span class="result-box" id="auctionQueryResultNFTTokenID">-</span>
        </div>

        <div class="aligned-container">
          <span class="result-box" id="auctionQueryIPFS">IPFS Metadata</span>
          <span class="result-box" id="auctionQueryResultIPFS">-</span>
        </div>

        <div class="aligned-container">
          <span class="result-box" id="auctionQueryWhitelist">Whitelist Auction</span>
          <span class="result-box" id="auctionQueryResultWhitelist">-</span>
        </div>

        <div class="aligned-container">
          <span class="result-box" id="auctionQueryBlacklist">Blacklist Auction</span>
          <span class="result-box" id="auctionQueryResultBlacklist">-</span>
        </div>

        <div class="aligned-container">
          <span class="result-box" id="auctionQueryCancellable">Cancellable Auction</span>
          <span class="result-box" id="auctionQueryResultCancellable">-</span>
        </div>

        <div class="aligned-container">
          <span class="result-box" id="auctionQueryCancelled">Cancelled Auction</span>
          <span class="result-box" id="auctionQueryResultCancelled">-</span>
        </div>

        <div class="aligned-container">
          <span class="result-box" id="auctionQueryEntryFee">Entry Fee (Ether)</span>
          <span class="result-box" id="auctionQueryResultEntryFee">-</span>
        </div>

        <div class="aligned-container">
          <span class="result-box" id="auctionQueryHighestBid">Highest Bid (Ether)</span>
          <span class="result-box" id="auctionQueryResultHighestBid">-</span>
        </div>

        <div class="aligned-container">
          <span class="result-box" id="auctionQueryWinnerAddress">Auction Winner's Address</span>
          <span class="result-box" id="auctionQueryResultWinnerAddress">-</span>
        </div>

        <div class="aligned-container">
          <span class="result-box" id="auctionQueryOwnerWithdraw">Owner Withdraw Status</span>
          <span class="result-box" id="auctionQueryResultOwnerWithdraw">-</span>
        </div>

      </div>

      <!-- Auction Whitelist Functions -->
      <div class="functionality-group auctionWhitelistFunctionalityGroup">
        <h2>Whitelist Auction Configuration Panel</h2>

        <h3>Check Whitelist Auction State</h3>

        <div class="aligned-container">
          <button class="admin-action-button" id="whitelistAuctionCheckButton">Check Whitelist Auction</button>
          <input type="text" class="admin-action-input" id="whitelistAuctionCheckInput" placeholder="Enter Auction ID"/>
          <span class="result-box" id="whitelistAuctionCheckSpan">-</span>
        </div>

        <div class="aligned-container">
          <button class="admin-action-button" id="whitelistAuctionParticipantCheckButton">Check Whitelist Participant</button>
          <input type="text" class="admin-action-input" id="whitelistAuctionParticipantCheckInputAuctionID" placeholder="Enter Auction ID"/>
          <input type="text" class="admin-action-input" id="whitelistAuctionParticipantCheckInputAddress" placeholder="Enter Address" />
          <span class="result-box" id="whitelistAuctionParticipantCheckSpan">-</span>
        </div>

        <h3>Confgure as Whitelist Auction</h3>

        <div class="aligned-container">
          <button class="admin-action-button" id="configureWhitelistAuctionButton">Configure Whitelist Auction</button>
          <input type="text" class="admin-action-input" id="configureWhitelistAuctionInputAuctionID" placeholder="Enter Auction ID"/>
          <span class="result-box" id="configureWhitelistAuctionSpan">-</span>
        </div>

        <h3>Whitelist Participants</h3>
        <div class="aligned-container">
          <button class="admin-action-button" id="whitelistParticipantsButton">Whitelist Participants</button>
          <input type="text" class="admin-action-input" id="whitelistParticipantsInputAuctionID" placeholder="Enter Auction ID"/>
          <textarea id="whitelistParticipantsInput" placeholder="Enter Addresses (one per line)" rows="5"></textarea>
          <span class="result-box" id="whitelistParticipantsSpan">-</span>
        </div>

      </div>

      <!-- Auction Blacklist Functions -->
      <div class="functionality-group auctionBlacklistFunctionalityGroup">
        <h2>Blacklist Auction Configuration Panel</h2>

        <h3>Check Blacklist Auction State</h3>

        <div class="aligned-container">
          <button class="admin-action-button" id="blacklistAuctionCheckButton">Check Blacklist Auction</button>
          <input type="text" class="admin-action-input" id="blacklistAuctionCheckInput" placeholder="Enter Auction ID"/>
          <span class="result-box" id="blacklistAuctionCheckSpan">-</span>
        </div>

        <div class="aligned-container">
          <button class="admin-action-button" id="blacklistAuctionParticipantCheckButton">Check Blacklist Participant</button>
          <input type="text" class="admin-action-input" id="blacklistAuctionParticipantCheckInputAuctionID" placeholder="Enter Auction ID"/>
          <input type="text" class="admin-action-input" id="blacklistAuctionParticipantCheckInputAddress" placeholder="Enter Address" />
          <span class="result-box" id="blacklistAuctionParticipantCheckSpan">-</span>
        </div>

        <h3>Confgure as Blacklist Auction</h3>

        <div class="aligned-container">
          <button class="admin-action-button" id="configureBlacklistAuctionButton">Configure Blacklist Auction</button>
          <input type="text" class="admin-action-input" id="configureBlacklistAuctionInputAuctionID" placeholder="Enter Auction ID"/>
          <span class="result-box" id="configureBlacklistAuctionSpan">-</span>
        </div>

        <h3>Blacklist Participants</h3>
        <div class="aligned-container">
          <button class="admin-action-button" id="blacklistParticipantsButton">Blacklist Participants</button>
          <input type="text" class="admin-action-input" id="blacklistParticipantsInputAuctionID" placeholder="Enter Auction ID"/>
          <textarea id="blacklistParticipantsInput" placeholder="Enter Addresses (one per line)" rows="5"></textarea>
          <span class="result-box" id="blacklistParticipantsSpan">-</span>
        </div>

      </div>

      <!-- Cancellable Auction Functions -->
      <div class="functionality-group auctionCancellableFunctionalityGroup">
        <h2>Cancellable Auction Configuration Panel</h2>

        <h3>Check Cancellable State</h3>

        <div class="aligned-container">
          <button class="admin-action-button" id="cancellableAuctionCheckButton">Check Cancellable State</button>
          <input type="text" class="admin-action-input" id="cancellableAuctionCheckInput" placeholder="Enter Auction ID"/>
          <span class="result-box" id="cancellableAuctionCheckSpan">-</span>
        </div>
        
        <h3>Check Cancelled State</h3>

        <div class="aligned-container">
          <button class="admin-action-button" id="cancelledAuctionCheckButton">Check if Auction is Cancelled</button>
          <input type="text" class="admin-action-input" id="cancelledAuctionCheckInput" placeholder="Enter Auction ID"/>
          <span class="result-box" id="cancelledAuctionCheckSpan">-</span>
        </div>

        <h3>Configure Cancellable Auction</h3>

        <div class="aligned-container">
          <button class="admin-action-button" id="configureCancellableAuctionButton">Configure as Cancellable</button>
          <input type="text" class="admin-action-input" id="configureCancellableAuctionInput" placeholder="Enter Auction ID"/>
          <span class="result-box" id="configureCancellableAuctionSpan">-</span>
        </div>

        <h3>Cancel an Auction</h3>

        <div class="aligned-container">
          <button class="admin-action-button" id="cancelAuctionButton">Cancel Auction</button>
          <input type="text" class="admin-action-input" id="cancelAuctionInput" placeholder="Enter Auction ID"/>
          <span class="result-box" id="cancelAuctionSpan">-</span>
        </div>
      </div>

      <!-- Entry Fee Auction Functions -->
      <div class="functionality-group auctionEntryFeeFunctionalityGroup">
        <h2>Entry Fee Configuration Panel</h2>

        <h3>Check Entry Fee Value</h3>

        <div class="aligned-container">
          <button class="admin-action-button" id="checkAuctionEntryFeeButton">Check Entry Fee</button>
          <input type="text" class="admin-action-input" id="checkAuctionEntryFeeInput" placeholder="Enter Auction ID"/>
          <span class="result-box" id="checkAuctionEntryFeeSpan">-</span>
        </div>
        
        <h3>Check Entry Fee Payment Status</h3>

        <div class="aligned-container">
          <button class="admin-action-button" id="hasPaidEntryFeeButton">Check Entry Fee Payment</button>
          <input type="text" class="admin-action-input" id="hasPaidEntryFeeInputAuctionID" placeholder="Enter Auction ID"/>
          <input type="text" class="admin-action-input" id="hasPaidEntryFeeInputParticipantAddress" placeholder="Enter Address"/>
          <span class="result-box" id="hasPaidEntryFeeSpan">-</span>
        </div>

        <h3>Check Entry Fee Withdrawal Status</h3>

        <div class="aligned-container">
          <button class="admin-action-button" id="hasWithdrawnEntryFeeButton">Check Entry Fee Withdrawal</button>
          <input type="text" class="admin-action-input" id="hasWithdrawnEntryFeeInputAuctionID" placeholder="Enter Auction ID"/>
          <input type="text" class="admin-action-input" id="hasWithdrawnEntryFeeInputParticipantAddress" placeholder="Enter Address"/>
          <span class="result-box" id="hasWithdrawnEntryFeeSpan">-</span>
        </div>

        <h3>Set Entry Fee</h3>

        <div class="aligned-container">
          <button class="admin-action-button" id="setEntryFeeButton">Set Entry Fee</button>
          <input type="text" class="admin-action-input" id="setEntryFeeInputAuctionID" placeholder="Enter Auction ID"/>
          <input type="text" class="admin-action-input" id="setEntryFeeInputEntryFeeAmountEther" placeholder="Entry Fee Ether"/>
          <span class="result-box" id="setEntryFeeSpan">-</span>
        </div>

      </div>

    </div>

    <footer id="appFooter" class="footer">
      <p>Developed by: Ruben Frisch (E-NIK, Business Informatics MSc)</p>
      <p>AuctionsLogic Contract (Arbitrum Sepolia Testnet): <a href="https://sepolia.arbiscan.io/address/0xA4A4aF21744295473D91b9f2f4F6DCA1AdA9e2f4#code" target="_blank">Contract Address</a></p>
      <p>AuctionERC721 Contract (Arbitrum Sepolia Testnet): <a href="https://sepolia.arbiscan.io/address/0x6FE5DC83A13B31D949a1fBDb3AE392122ba99F86#code" target="_blank">Contract Address</a></p>
      <p>EVM Node Connector Provided by <a href="https://docs.web3js.org/" target="_blank">Web3.js API</a></p>
      <p>Wallet Infrastructure Provided by <a href="https://metamask.io/" target="_blank">Metamask</a></p> 
      <p>Testnet Infrastructure Provided by <a href="https://arbitrum.io/" target="_blank">Arbitrum</a></p> 
      <p>Chain ID Information Provided by <a href="https://chainlist.org/" target="_blank">ChainList</a></p> 
    </footer>

  </div>

  <script src="https://cdn.jsdelivr.net/npm/web3@1.6.1/dist/web3.min.js"></script>

  <script>
    let web3;
    let auctionContract;
    let nftContract;
    let userAddress;
    let latestBlock = null;

    const auctionABI = [{ "anonymous": false, "inputs": [{ "indexed": true, "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "AddedBlacklistedParticipants", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "AddedWhitelistedParticipants", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "AuctionCancelled", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "AuctionConfiguredAsBlacklisted", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "AuctionConfiguredAsCancellable", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "AuctionConfiguredAsClosed", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }, { "indexed": false, "internalType": "address", "name": "bidder_", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "newHighestBidAmount_", "type": "uint256" }], "name": "BidPlaced", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }, { "indexed": false, "internalType": "address", "name": "entity_", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "withdrawAmount_", "type": "uint256" }], "name": "BidWithdrawn", "type": "event" }, { "anonymous": false, "inputs": [], "name": "EmergencyPauseTurnedOff", "type": "event" }, { "anonymous": false, "inputs": [], "name": "EmergencyPauseTurnedOn", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }, { "indexed": false, "internalType": "uint256", "name": "entryFeeValue_", "type": "uint256" }], "name": "EntryFeeConfigured", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }, { "indexed": false, "internalType": "address", "name": "entity_", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "paidEntryFeeAmount_", "type": "uint256" }], "name": "EntryFeePaid", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }, { "indexed": false, "internalType": "address", "name": "entity_", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "withdrawnEntryFeeAmount_", "type": "uint256" }], "name": "EntryFeeWithdrawn", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "NewAuctionRegistered", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "previousOwner_", "type": "address" }, { "indexed": true, "internalType": "address", "name": "newOwner_", "type": "address" }], "name": "OwnershipTransferCompleted", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "owner_", "type": "address" }, { "indexed": true, "internalType": "address", "name": "pendingOwner_", "type": "address" }], "name": "OwnershipTransferInitiated", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "owner_", "type": "address" }], "name": "RenounceProcessInitiated", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "owner_", "type": "address" }], "name": "RenounceProcessTerminated", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": false, "internalType": "address", "name": "signer_", "type": "address" }], "name": "SignatureRegistered", "type": "event" }, { "anonymous": false, "inputs": [], "name": "SignatureValidityTimeCountdownStarted", "type": "event" }, { "anonymous": false, "inputs": [], "name": "SignaturesExpiredAndReset", "type": "event" }, { "anonymous": false, "inputs": [], "name": "SignaturesReset", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }, { "indexed": false, "internalType": "address", "name": "bidder_", "type": "address" }], "name": "SnipePreventionTriggered", "type": "event" }, { "anonymous": false, "inputs": [], "name": "SocialGuardianRecoveryCompleted", "type": "event" }, { "anonymous": false, "inputs": [], "name": "TimeLockQueueReset", "type": "event" }, { "anonymous": false, "inputs": [], "name": "TimelockQueueStarted", "type": "event" }, { "inputs": [], "name": "acceptOwnership", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "auctionEndBlock", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "auctionExists", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "auctionHighestBidAmount", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "auctionSnipeBlocks", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "auctionSnipeInterval", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "auctionStartBlock", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "auctionWinner", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "bid", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "payable", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "bidIncrement", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }, { "internalType": "address[]", "name": "participants_", "type": "address[]" }], "name": "blacklistParticipants", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "cancelAuction", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "closedAuction", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "configureAsBlacklistedAuction", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "configureAsCancellableAuction", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "configureAsClosedAuction", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "contractETHBalance", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }, { "internalType": "uint256", "name": "auctionStartBlock_", "type": "uint256" }, { "internalType": "uint256", "name": "auctionEndBlock_", "type": "uint256" }, { "internalType": "uint256", "name": "startingPrice_", "type": "uint256" }, { "internalType": "uint256", "name": "bidIncrement_", "type": "uint256" }, { "internalType": "uint256", "name": "reservePrice_", "type": "uint256" }, { "internalType": "uint256", "name": "auctionSnipeInterval_", "type": "uint256" }, { "internalType": "uint256", "name": "auctionSnipeBlocks_", "type": "uint256" }, { "internalType": "address", "name": "nftContractAddress_", "type": "address" }, { "internalType": "uint256", "name": "nftTokenID_", "type": "uint256" }, { "internalType": "string", "name": "ipfs_", "type": "string" }], "name": "createNewAuction", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "currentSignatureCount", "outputs": [{ "internalType": "uint8", "name": "", "type": "uint8" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }, { "internalType": "address", "name": "bidder_", "type": "address" }], "name": "getBidAmountOfBidder", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "getEntryFee", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "getIPFS", "outputs": [{ "internalType": "string", "name": "", "type": "string" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "getQueueTime", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "getSignatureExpiryTime", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }, { "internalType": "address", "name": "participant_", "type": "address" }], "name": "hasPaidEntryFee", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "signer_", "type": "address" }], "name": "hasSigned", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }, { "internalType": "address", "name": "participant_", "type": "address" }], "name": "hasWithdrawnEntryFee", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "isBlacklistAuction", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }, { "internalType": "address", "name": "participant_", "type": "address" }], "name": "isBlacklistedParticipant", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "isCancellable", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "isCancelled", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "isPaused", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "signer_", "type": "address" }], "name": "isSigner", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }, { "internalType": "address", "name": "participant_", "type": "address" }], "name": "isWhitelisted", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "nftContractAddress", "outputs": [{ "internalType": "contract AuctionERC721", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "nftTokenID", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "", "type": "address" }, { "internalType": "address", "name": "", "type": "address" }, { "internalType": "uint256", "name": "", "type": "uint256" }, { "internalType": "bytes", "name": "", "type": "bytes" }], "name": "onERC721Received", "outputs": [{ "internalType": "bytes4", "name": "", "type": "bytes4" }], "stateMutability": "pure", "type": "function" }, { "inputs": [], "name": "owner", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "ownerWithdrew", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "payEntryFee", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "payable", "type": "function" }, { "inputs": [], "name": "pendingOwner", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "registerSignature", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "renounceOwnership", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "renounceUnlocked", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "reservePrice", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "resetPendingOwner", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }, { "internalType": "uint256", "name": "entryFee_", "type": "uint256" }], "name": "setEntryFee", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "newOwner_", "type": "address" }], "name": "socialGuardianRecovery", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "startQueue", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "startRenounceProcess", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "startingPrice", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "terminateRenounceProcess", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "newOwner_", "type": "address" }], "name": "transferOwnership", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "turnEmergencyPauseOff", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "turnEmergencyPauseOn", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }, { "internalType": "address[]", "name": "participants_", "type": "address[]" }], "name": "whitelistParticipants", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "withdrawBid", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "auctionID_", "type": "bytes32" }], "name": "withdrawEntryFee", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }];
    const nftABI = [{ "inputs": [], "stateMutability": "nonpayable", "type": "constructor" }, { "inputs": [{ "internalType": "address", "name": "sender", "type": "address" }, { "internalType": "uint256", "name": "tokenId", "type": "uint256" }, { "internalType": "address", "name": "owner", "type": "address" }], "name": "ERC721IncorrectOwner", "type": "error" }, { "inputs": [{ "internalType": "address", "name": "operator", "type": "address" }, { "internalType": "uint256", "name": "tokenId", "type": "uint256" }], "name": "ERC721InsufficientApproval", "type": "error" }, { "inputs": [{ "internalType": "address", "name": "approver", "type": "address" }], "name": "ERC721InvalidApprover", "type": "error" }, { "inputs": [{ "internalType": "address", "name": "operator", "type": "address" }], "name": "ERC721InvalidOperator", "type": "error" }, { "inputs": [{ "internalType": "address", "name": "owner", "type": "address" }], "name": "ERC721InvalidOwner", "type": "error" }, { "inputs": [{ "internalType": "address", "name": "receiver", "type": "address" }], "name": "ERC721InvalidReceiver", "type": "error" }, { "inputs": [{ "internalType": "address", "name": "sender", "type": "address" }], "name": "ERC721InvalidSender", "type": "error" }, { "inputs": [{ "internalType": "uint256", "name": "tokenId", "type": "uint256" }], "name": "ERC721NonexistentToken", "type": "error" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "owner", "type": "address" }, { "indexed": true, "internalType": "address", "name": "approved", "type": "address" }, { "indexed": true, "internalType": "uint256", "name": "tokenId", "type": "uint256" }], "name": "Approval", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "owner", "type": "address" }, { "indexed": true, "internalType": "address", "name": "operator", "type": "address" }, { "indexed": false, "internalType": "bool", "name": "approved", "type": "bool" }], "name": "ApprovalForAll", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": false, "internalType": "uint256", "name": "_fromTokenId", "type": "uint256" }, { "indexed": false, "internalType": "uint256", "name": "_toTokenId", "type": "uint256" }], "name": "BatchMetadataUpdate", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": false, "internalType": "uint256", "name": "_tokenId", "type": "uint256" }], "name": "MetadataUpdate", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "previousOwner_", "type": "address" }, { "indexed": true, "internalType": "address", "name": "newOwner_", "type": "address" }], "name": "OwnershipTransferCompleted", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "owner_", "type": "address" }, { "indexed": true, "internalType": "address", "name": "pendingOwner_", "type": "address" }], "name": "OwnershipTransferInitiated", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "owner_", "type": "address" }], "name": "RenounceProcessInitiated", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "owner_", "type": "address" }], "name": "RenounceProcessTerminated", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": false, "internalType": "address", "name": "signer_", "type": "address" }], "name": "SignatureRegistered", "type": "event" }, { "anonymous": false, "inputs": [], "name": "SignatureValidityTimeCountdownStarted", "type": "event" }, { "anonymous": false, "inputs": [], "name": "SignaturesExpiredAndReset", "type": "event" }, { "anonymous": false, "inputs": [], "name": "SignaturesReset", "type": "event" }, { "anonymous": false, "inputs": [], "name": "SocialGuardianRecoveryCompleted", "type": "event" }, { "anonymous": false, "inputs": [], "name": "TimeLockQueueReset", "type": "event" }, { "anonymous": false, "inputs": [], "name": "TimelockQueueStarted", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "from", "type": "address" }, { "indexed": true, "internalType": "address", "name": "to", "type": "address" }, { "indexed": true, "internalType": "uint256", "name": "tokenId", "type": "uint256" }], "name": "Transfer", "type": "event" }, { "inputs": [], "name": "acceptOwnership", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "tokenId", "type": "uint256" }], "name": "approve", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "owner", "type": "address" }], "name": "balanceOf", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "tokenId", "type": "uint256" }], "name": "burn", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "currentSignatureCount", "outputs": [{ "internalType": "uint8", "name": "", "type": "uint8" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "tokenId", "type": "uint256" }], "name": "getApproved", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "getQueueTime", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "getSignatureExpiryTime", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "signer_", "type": "address" }], "name": "hasSigned", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "address", "name": "operator", "type": "address" }], "name": "isApprovedForAll", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "signer_", "type": "address" }], "name": "isSigner", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "name", "outputs": [{ "internalType": "string", "name": "", "type": "string" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "owner", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "tokenId", "type": "uint256" }], "name": "ownerOf", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "pendingOwner", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "registerSignature", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "renounceOwnership", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "renounceUnlocked", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "resetPendingOwner", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "to_", "type": "address" }, { "internalType": "string", "name": "uri_", "type": "string" }], "name": "safeMint", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "from", "type": "address" }, { "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "tokenId", "type": "uint256" }], "name": "safeTransferFrom", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "from", "type": "address" }, { "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "tokenId", "type": "uint256" }, { "internalType": "bytes", "name": "data", "type": "bytes" }], "name": "safeTransferFrom", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "operator", "type": "address" }, { "internalType": "bool", "name": "approved", "type": "bool" }], "name": "setApprovalForAll", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "newOwner_", "type": "address" }], "name": "socialGuardianRecovery", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "startQueue", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "startRenounceProcess", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "bytes4", "name": "interfaceID_", "type": "bytes4" }], "name": "supportsInterface", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "symbol", "outputs": [{ "internalType": "string", "name": "", "type": "string" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "terminateRenounceProcess", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "tokenID_", "type": "uint256" }], "name": "tokenURI", "outputs": [{ "internalType": "string", "name": "", "type": "string" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "from", "type": "address" }, { "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "tokenId", "type": "uint256" }], "name": "transferFrom", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "newOwner_", "type": "address" }], "name": "transferOwnership", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }];

    const auctionAddress = '0xA4A4aF21744295473D91b9f2f4F6DCA1AdA9e2f4';
    const nftAddress = '0x6FE5DC83A13B31D949a1fBDb3AE392122ba99F86';

    const networkMap = {
      '0x1': 'Ethereum Mainnet',
      '0x3': 'Ropsten Testnet',
      '0x4': 'Rinkeby Testnet',
      '0x5': 'Goerli Testnet',
      '0x2a': 'Kovan Testnet',
      '0x89': 'Polygon Mainnet',
      '0x44d': 'Polygon zkEVM',
      '0x13881': 'Polygon Testnet Mumbai',
      '0xa86a': 'Avalanche Mainnet',
      '0xa869': 'Avalanche Fuji Testnet',
      '0xfa': 'Fantom Mainnet',
      '0x61': 'Binance Smart Chain Testnet',
      '0x38': 'Binance Smart Chain Mainnet',
      '0x507': 'Moonbase Alpha',
      '0x507': 'Moonriver',
      '0x507': 'Moonbeam',
      '0x66eee': 'Arbitrum Sepolia Testnet',
      '0xa4b1': 'Arbitrum One Mainnet',
      '0xa4ba': 'Arbitrum Nova Mainnet',
      '0x144': 'zkSync Era Mainnet',
      '0x12c': 'zkSync Era Sepolia Testnet',
      '0x2105': 'Base Mainnet',
      '0x14a34': 'Base Sepolia Testnet',
      '0xa': 'Optimism Mainnet',
      '0xcc': 'opBNB Mainnet',
      '0x82750': 'Scroll Mainnet',
      '0xe708': 'Linea Mainnet',
      '0x19': 'Cronos Mainnet',
      '0x184': 'Cronos zkEVM Mainnet',
      '0x1388': 'Mantle Mainnet',
      '0x64': 'Gnosis Mainnet',
      '0x13a': 'Filecoin Mainnet',
      '0xa4ec': 'Celo Mainnet',
      '0x440': 'Metis Andromeda Mainnet',
      '0xa9': 'Manta Pacific Mainnet',
      '0x250': 'Astar Mainnet',
      '0x343b': 'Immutable zkEVM',
      '0x15b38': 'Chilliz Chain Mainnet',
      '0x4571': 'EOS EVM Network Mainnet',
      '0x76adf1': 'Zora Mainnet'
    };

    const signers = [
      "0x8c2B9A3a790E68935539615f57597E1ea5E93f00",
      "0x1f47A72D9518E37480c1182b91Ac0e0e4636803F",
      "0xceA32CB1362d5fA979ad2d46c3828EC1a048E75d",
      "0x7C8C9C31D3C69FE45A8B5ebaA0d16F427e35c046",
      "0xF2e00393Ed39446AAD3661C5AdeBfB609ea93938",
      "0x951dAC66A78DcdbC61a0F97b20303caB946a0277",
      "0xFa4c7D1df00Ad6FA63b93Bd2762Fe05786D021C6"
    ];

    window.addEventListener('load', async () => {
      //Connect + Disconnect wallet DOM getters
      const connectButton = document.getElementById('connectButton');
      const disconnectButton = document.getElementById('disconnectButton');

      //Automatically reconnect if a wallet was previously connected
      const savedWallet = localStorage.getItem('connectedWallet');

      if (savedWallet) {
        userAddress = savedWallet;
        document.getElementById('walletAddress').textContent = `Connected Wallet: ${userAddress}`;

        document.getElementById('connectButton').style.display = 'none';
        document.getElementById('disconnectButton').style.display = 'block';

        document.getElementById('networkName').style.display = 'block';
        document.getElementById('walletAddress').style.display = 'block';

        //Show the toggle interface button if there is a saved wallet
        const toggleButton = document.getElementById("toggleButton");
        toggleButton.style.display = 'block';

        //When the page is reloaded, we should show the correct functionality page
        const viewMode = localStorage.getItem('viewMode');

        //Show the appropriate interface (when we load the page) based on the value of the viewMode local browser storage variable
        if (viewMode === 'auction') {
          document.getElementById('adminFunctions').style.display = 'none';
          document.getElementById("auctionFunctions").style.display = 'block';
          document.getElementById('refreshButton').style.display = 'block';
          document.getElementById('metamaskHeader2').style.display = 'none';
          toggleButton.textContent = "Show Admin Interface";
        } else {
          //Default to admin view if no value is stored or viewMode is 'admin'
          document.getElementById("auctionFunctions").style.display = 'none';
          document.getElementById('adminFunctions').style.display = 'block';
          document.getElementById('refreshButton').style.display = 'block';
          document.getElementById('metamaskHeader2').style.display = 'none';
          toggleButton.textContent = "Show Auction Interface";
        }

        //Initialize contracts
        web3 = new Web3(window.ethereum);

        auctionContract = new web3.eth.Contract(auctionABI, auctionAddress);
        nftContract = new web3.eth.Contract(nftABI, nftAddress);

        if (latestBlock == null) {
          latestBlock = await web3.eth.getBlockNumber();
        }

        await getNetworkName();

        //When the user changes the network in Metamask, update the network displayed on the UI with the correct network name based on the chainID
        window.ethereum.on('chainChanged', async (chainId) => {
          console.log(`Chain changed to ${chainId}, updating web3 instance...`);
          await getNetworkName();
          getNetworkName();
          window.location.reload();
        });

        //When the user changes the account in Metamask, that new wallet should be connected to the frontend
        window.ethereum.on('accountsChanged', async (accounts) => {
          if (accounts.length > 0) {
            console.log('Account changed:', accounts[0]);

            //Call the connectWallet function to reconnect and request the signature
            await connectWallet();

          } else {
            console.log('No account connected');
          }
        });

        await checkPauseStatus();
        await checkCurrentOwner();
        await checkPendingOwner();
        await checkRenounceUnlockedStatus();

        await checkQueueTime();
        await calculateQueueCountdownDate();

        await checkMultiSigExpiryTime();
        await displaySigners();
        await checkMultiSigCurrentSignatureCount();
        await checkNameAndSymbol();
        await auctionRegistrationLatestBlockNumberDisplay();

      }

      //Page reload button DOM
      const refreshButton = document.getElementById('refreshButton');

      //Toggle Button Click event Listener to change interface if the button is clicked
      document.getElementById("toggleButton").addEventListener("click", function() {
        clearErrorLog();
        if (document.getElementById("auctionFunctions").style.display === "none") {
            document.getElementById('adminFunctions').style.display = 'none';
            document.getElementById("auctionFunctions").style.display = 'block';
            document.getElementById('connectButton').style.display = 'none';
            document.getElementById('disconnectButton').style.display = 'block';
            document.getElementById('refreshButton').style.display = 'block';
            document.getElementById('metamaskHeader2').style.display = 'none';
            toggleButton.textContent = "Show Admin Interface";
            localStorage.setItem('viewMode', 'auction'); //Store the view mode in localStorage
        } else {
            document.getElementById("auctionFunctions").style.display = 'none';
            document.getElementById('adminFunctions').style.display = 'block';
            document.getElementById('connectButton').style.display = 'none';
            document.getElementById('disconnectButton').style.display = 'block';
            document.getElementById('refreshButton').style.display = 'block';
            document.getElementById('metamaskHeader2').style.display = 'none';
            toggleButton.textContent = "Show Auction Interface";
            localStorage.setItem('viewMode', 'admin'); //Store the view mode in localStorage
        }
      });

      //PAUSE functionality DOM getters
      const checkPauseButton = document.getElementById('checkPauseButton');
      const turnPauseOnButton = document.getElementById('turnPauseOnButton');
      const turnPauseOffButton = document.getElementById('turnPauseOffButton');
      const pauseFeedback_ON = document.getElementById('pauseFeedback_ON');
      const pauseFeedback_OFF = document.getElementById('pauseFeedback_OFF');

      //OWNERSHIP functionality DOM getters
      const checkCurrentOwnerButton = document.getElementById('checkCurrentOwnerButton');
      const checkPendingOwnerButton = document.getElementById('checkPendingOwnerButton');
      const checkRenounceUnlockedStatusButton = document.getElementById('checkRenounceUnlockedStatusButton');
      const startRenounceProcessButton = document.getElementById('startRenounceProcessButton');
      const startRenounceProcessSpan = document.getElementById('startRenounceProcessSpan');
      const terminateRenounceProcessButton = document.getElementById('terminateRenounceProcessButton');
      const terminateRenounceProcessSpan = document.getElementById('terminateRenounceProcessSpan');
      const renounceOwnershipButton = document.getElementById('renounceOwnershipButton');
      const renounceOwnershipSpan = document.getElementById('renounceOwnershipSpan');
      const transferOwnershipButton = document.getElementById('transferOwnershipButton');
      const transferOwnershipInput = document.getElementById('transferOwnershipInput');
      const transferOwnershipSpan = document.getElementById('transferOwnershipSpan');
      const acceptOwnershipButton = document.getElementById('acceptOwnershipButton');
      const acceptOwnershipSpan = document.getElementById('acceptOwnershipSpan');
      const resetPendingOwnerButton = document.getElementById('resetPendingOwnerButton');
      const resetPendingOwnerSpan = document.getElementById('resetPendingOwnerSpan');
      const socialGuardianRecoveryButton = document.getElementById('socialGuardianRecoveryButton');
      const socialGuardianRecoveryInput = document.getElementById('socialGuardianRecoveryInput');
      const socialGuardianRecoverySpan = document.getElementById('socialGuardianRecoverySpan');

      //TIMELOCK functionality DOM getters
      const queueTimeButton = document.getElementById('queueTimeButton');
      const timelockCountdownButton = document.getElementById('timelockCountdownButton');
      const timelockStartQueueButton = document.getElementById('timelockStartQueueButton');
      const timelockStartQueue = document.getElementById('timelockStartQueue');

      //MULTISIG functionality DOM getters
      const multiSigExpiryTimeButton = document.getElementById('multiSigExpiryTimeButton');
      const multiSigCurrentSignatureCountButton = document.getElementById('multiSigCurrentSignatureCountButton');
      const multiSigCheckSignerButton = document.getElementById('multiSigCheckSignerButton');
      const multiSigHasSignedButton = document.getElementById('multiSigHasSignedButton');
      const multiSigRegisterSignatureButton = document.getElementById('multiSigRegisterSignatureButton');
      const multiSigRegisterSignatureSpan = document.getElementById('multiSigRegisterSignatureSpan');

      //NFT functionality DOM getters
      const mintNFTButton = document.getElementById('mintNFTButton');
      const mintNFTAddressInput = document.getElementById('mintNFTAddressInput');
      const mintNFTURIInput = document.getElementById('mintNFTURIInput');
      const mintNFTSpan = document.getElementById('mintNFTSpan');
      const balanceOfNFTButton = document.getElementById('balanceOfNFTButton');
      const balanceOfNFTInput = document.getElementById('balanceOfNFTInput');
      const balanceOfNFTSpan = document.getElementById('balanceOfNFTSpan');
      const ownerOfNFTButton = document.getElementById('ownerOfNFTButton');
      const ownerOfNFTInput = document.getElementById('ownerOfNFTInput');
      const ownerOfNFTSpan = document.getElementById('ownerOfNFTSpan');
      const tokenURINFTButton = document.getElementById('tokenURINFTButton');
      const tokenURINFTInput = document.getElementById('tokenURINFTInput');
      const tokenURINFTSpan = document.getElementById('tokenURINFTSpan');
      const nftCollectionNameSpan = document.getElementById('nftCollectionNameSpan');
      const nftCollectionSymbolSpan = document.getElementById('nftCollectionSymbolSpan');
      const burnNFTButton = document.getElementById('burnNFTButton');
      const burnNFTInput = document.getElementById('burnNFTInput');
      const burnNFTSpan = document.getElementById('burnNFTSpan');
      const approveNFTButton = document.getElementById('approveNFTButton');
      const approveNFTInputID = document.getElementById('approveNFTInputID');
      const approveNFTInputAddress = document.getElementById('approveNFTInputAddress');
      const approveNFTSpan = document.getElementById('approveNFTSpan');
      const getApprovedNFTButton = document.getElementById('getApprovedNFTButton');
      const getApprovedNFTInput = document.getElementById('getApprovedNFTInput');
      const getApprovedNFTSpan = document.getElementById('getApprovedNFTSpan');
      const resetApprovalNFTButton = document.getElementById('resetApprovalNFTButton');
      const resetApprovalNFTInput = document.getElementById('resetApprovalNFTInput');
      const resetApprovalNFTSpan = document.getElementById('resetApprovalNFTSpan');
      const setApprovalForAllNFTButton = document.getElementById('setApprovalForAllNFTButton');
      const setApprovalForAllNFTInput = document.getElementById('setApprovalForAllNFTInput');
      const setApprovalForAllNFTSpan = document.getElementById('setApprovalForAllNFTSpan');
      const checkApprovalForAllNFTButton = document.getElementById('checkApprovalForAllNFTButton');
      const checkApprovalForAllNFTInputOwnerAddress = document.getElementById('checkApprovalForAllNFTInputOwnerAddress');
      const checkApprovalForAllNFTInputOperatorAddress = document.getElementById('checkApprovalForAllNFTInputOperatorAddress');
      const checkApprovalForAllNFTSpan = document.getElementById('checkApprovalForAllNFTSpan');
      const resetApprovalForAllNFTButton = document.getElementById('resetApprovalForAllNFTButton');
      const resetApprovalForAllNFTInput = document.getElementById('resetApprovalForAllNFTInput');
      const resetApprovalForAllNFTSpan = document.getElementById('resetApprovalForAllNFTSpan');
      const transferNFTButton = document.getElementById('transferNFTButton');
      const transferNFTInputFROM = document.getElementById('transferNFTInputFROM');
      const transferNFTInputTO = document.getElementById('transferNFTInputTO');
      const transferNFTInputTokenID = document.getElementById('transferNFTInputTokenID');
      const transferNFTSpan = document.getElementById('transferNFTSpan');

      //Auction Registration DOM getters
      const auctionIDInput = document.getElementById('auctionIDInput');
      const auctionStartBlockInput = document.getElementById('auctionStartBlockInput');
      const auctionEndBlockInput = document.getElementById('auctionEndBlockInput');
      const startingPriceInput = document.getElementById('startingPriceInput');
      const bidIncrementInput = document.getElementById('bidIncrementInput');
      const reservePriceInput = document.getElementById('reservePriceInput');
      const auctionSnipeIntervalInput = document.getElementById('auctionSnipeIntervalInput');
      const auctionSnipeBlocksInput = document.getElementById('auctionSnipeBlocksInput');
      const nftContractAddressInput = document.getElementById('nftContractAddressInput');
      const nftTokenIDInput = document.getElementById('nftTokenIDInput');
      const ipfsStringInput = document.getElementById('ipfsStringInput');
      const registerAuctionButton = document.getElementById('registerAuctionButton');
      const startingPriceSlider = document.getElementById('startingPriceSlider');
      const latestBlockNumberSpan = document.getElementById('latestBlockNumberSpan');
      const auctionStartBlockErrorSpan = document.getElementById('auctionStartBlockErrorSpan');
      const auctionEndBlockErrorSpan = document.getElementById('auctionEndBlockErrorSpan');
      const bidIncrementSlider = document.getElementById('bidIncrementSlider');
      const reservePriceSlider = document.getElementById('reservePriceSlider');
      const startingPriceErrorSpan = document.getElementById('startingPriceErrorSpan');
      const nftContractAddressErrorSpan = document.getElementById('nftContractAddressErrorSpan');
      const nftTokenIDErrorSpan = document.getElementById('nftTokenIDErrorSpan');
      const ipfsStringErrorSpan = document.getElementById('ipfsStringErrorSpan');
      const registerAuctionErrorSpan = document.getElementById('registerAuctionErrorSpan');

      //Whitelist DOM getters
      const whitelistAuctionCheckButton = document.getElementById('whitelistAuctionCheckButton');
      const whitelistAuctionCheckInput = document.getElementById('whitelistAuctionCheckInput');
      const whitelistAuctionCheckSpan = document.getElementById('whitelistAuctionCheckSpan');
      const whitelistAuctionParticipantCheckButton = document.getElementById('whitelistAuctionParticipantCheckButton');
      const whitelistAuctionParticipantCheckInputAuctionID = document.getElementById('whitelistAuctionParticipantCheckInputAuctionID');
      const whitelistAuctionParticipantCheckInputAddress = document.getElementById('whitelistAuctionParticipantCheckInputAddress');
      const whitelistAuctionParticipantCheckSpan = document.getElementById('whitelistAuctionParticipantCheckSpan');
      const configureWhitelistAuctionButton = document.getElementById('configureWhitelistAuctionButton');
      const configureWhitelistAuctionInputAuctionID = document.getElementById('configureWhitelistAuctionInputAuctionID');
      const configureWhitelistAuctionSpan = document.getElementById('configureWhitelistAuctionSpan');
      const whitelistParticipantsButton = document.getElementById('whitelistParticipantsButton');
      const whitelistParticipantsInput = document.getElementById('whitelistParticipantsInput');
      const whitelistParticipantsSpan = document.getElementById('whitelistParticipantsSpan');

      //Blacklist DOM getters
      const blacklistAuctionCheckButton = document.getElementById('blacklistAuctionCheckButton');
      const blacklistAuctionCheckInput = document.getElementById('blacklistAuctionCheckInput');
      const blacklistAuctionCheckSpan = document.getElementById('blacklistAuctionCheckSpan');
      const blacklistAuctionParticipantCheckButton = document.getElementById('blacklistAuctionParticipantCheckButton');
      const blacklistAuctionParticipantCheckInputAuctionID = document.getElementById('blacklistAuctionParticipantCheckInputAuctionID');
      const blacklistAuctionParticipantCheckInputAddress = document.getElementById('blacklistAuctionParticipantCheckInputAddress');
      const blacklistAuctionParticipantCheckSpan = document.getElementById('blacklistAuctionParticipantCheckSpan');
      const configureBlacklistAuctionButton = document.getElementById('configureBlacklistAuctionButton');
      const configureBlacklistAuctionInputAuctionID = document.getElementById('configureBlacklistAuctionInputAuctionID');
      const configureBlacklistAuctionSpan = document.getElementById('configureBlacklistAuctionSpan');
      const blacklistParticipantsButton = document.getElementById('blacklistParticipantsButton');
      const blacklistParticipantsInput = document.getElementById('blacklistParticipantsInput');
      const blacklistParticipantsSpan = document.getElementById('blacklistParticipantsSpan');

      //Cancellable, Cancellation DOM getters
      const cancellableAuctionCheckButton = document.getElementById('cancellableAuctionCheckButton');
      const cancellableAuctionCheckInput = document.getElementById('cancellableAuctionCheckInput');
      const cancellableAuctionCheckSpan = document.getElementById('cancellableAuctionCheckSpan');
      const cancelledAuctionCheckButton = document.getElementById('cancelledAuctionCheckButton');
      const cancelledAuctionCheckInput = document.getElementById('cancelledAuctionCheckInput');
      const cancelledAuctionCheckSpan = document.getElementById('cancelledAuctionCheckSpan');
      const configureCancellableAuctionButton = document.getElementById('configureCancellableAuctionButton');
      const configureCancellableAuctionInput = document.getElementById('configureCancellableAuctionInput');
      const configureCancellableAuctionSpan = document.getElementById('configureCancellableAuctionSpan');
      const cancelAuctionButton = document.getElementById('cancelAuctionButton');
      const cancelAuctionInput = document.getElementById('cancelAuctionInput');
      const cancelAuctionSpan = document.getElementById('cancelAuctionSpan');

      //Entry Fee DOM getters
      const checkAuctionEntryFeeButton = document.getElementById('checkAuctionEntryFeeButton');
      const checkAuctionEntryFeeInput = document.getElementById('checkAuctionEntryFeeInput');
      const checkAuctionEntryFeeSpan = document.getElementById('checkAuctionEntryFeeSpan');
      const hasPaidEntryFeeButton = document.getElementById('hasPaidEntryFeeButton');
      const hasPaidEntryFeeInputAuctionID = document.getElementById('hasPaidEntryFeeInputAuctionID');
      const hasPaidEntryFeeInputParticipantAddress = document.getElementById('hasPaidEntryFeeInputParticipantAddress');
      const hasPaidEntryFeeSpan = document.getElementById('hasPaidEntryFeeSpan');
      const hasWithdrawnEntryFeeButton = document.getElementById('hasWithdrawnEntryFeeButton');
      const hasWithdrawnEntryFeeInputAuctionID = document.getElementById('hasWithdrawnEntryFeeInputAuctionID');
      const hasWithdrawnEntryFeeInputParticipantAddress = document.getElementById('hasWithdrawnEntryFeeInputParticipantAddress');
      const hasWithdrawnEntryFeeSpan = document.getElementById('hasWithdrawnEntryFeeSpan');
      const setEntryFeeButton = document.getElementById('setEntryFeeButton');
      const setEntryFeeInputAuctionID = document.getElementById('setEntryFeeInputAuctionID');
      const setEntryFeeInputEntryFeeAmountEther = document.getElementById('setEntryFeeInputEntryFeeAmountEther');
      const setEntryFeeSpan = document.getElementById('setEntryFeeSpan');

      //Auction Query Tool DOM getters
      const queryAuctionButton = document.getElementById('queryAuctionButton');
      const queryAuctionInput = document.getElementById('queryAuctionInput');
      const queryAuctionSpan = document.getElementById('queryAuctionSpan');
      const auctionQueryResultStartBlock = document.getElementById('auctionQueryResultStartBlock');
      const auctionQueryResultEndBlock= document.getElementById('auctionQueryResultEndBlock');
      const auctionQueryResultStartingPrice = document.getElementById('auctionQueryResultStartingPrice');
      const auctionQueryResultBidIncrement = document.getElementById('auctionQueryResultBidIncrement');
      const auctionQueryResultReservePrice = document.getElementById('auctionQueryResultReservePrice');
      const auctionQueryResultSnipeInterval = document.getElementById('auctionQueryResultSnipeInterval');
      const auctionQueryResultSnipeBlocks = document.getElementById('auctionQueryResultSnipeBlocks');
      const auctionQueryResultNFTContractAddress = document.getElementById('auctionQueryResultNFTContractAddress');
      const auctionQueryResultNFTTokenID = document.getElementById('auctionQueryResultNFTTokenID');
      const auctionQueryResultIPFS = document.getElementById('auctionQueryResultIPFS');
      const auctionQueryResultWhitelist = document.getElementById('auctionQueryResultWhitelist');
      const auctionQueryResultBlacklist = document.getElementById('auctionQueryResultBlacklist');
      const auctionQueryResultCancellable = document.getElementById('auctionQueryResultCancellable');
      const auctionQueryResultCancelled = document.getElementById('auctionQueryResultCancelled');
      const auctionQueryResultEntryFee = document.getElementById('auctionQueryResultEntryFee');
      const auctionQueryResultHighestBid = document.getElementById('auctionQueryResultHighestBid');
      const auctionQueryResultWinnerAddress = document.getElementById('auctionQueryResultWinnerAddress');
      const auctionQueryResultOwnerWithdraw = document.getElementById('auctionQueryResultOwnerWithdraw');

      //Connect + Disconnect wallet Event Listeners
      connectButton.addEventListener('click', connectWallet);
      disconnectButton.addEventListener('click', disconnectWallet);

      //REFRESH button functionality event listener
      refreshButton.addEventListener('click', refreshButtonFunction);

      //PAUSE functionality Event Listeners
      checkPauseButton.addEventListener('click', checkPauseStatus);
      turnPauseOnButton.addEventListener('click', turnEmergencyPauseOn);
      turnPauseOffButton.addEventListener('click', turnEmergencyPauseOff);

      //OWNERSHIP functionality Event Listeners
      checkCurrentOwnerButton.addEventListener('click', checkCurrentOwner);
      checkPendingOwnerButton.addEventListener('click', checkPendingOwner);
      checkRenounceUnlockedStatusButton.addEventListener('click', checkRenounceUnlockedStatus);
      startRenounceProcessButton.addEventListener('click', startRenounceProcess);
      terminateRenounceProcessButton.addEventListener('click', terminateRenounceProcess);
      renounceOwnershipButton.addEventListener('click', renounceOwnership);
      transferOwnershipButton.addEventListener('click', transferOwnership);
      acceptOwnershipButton.addEventListener('click', acceptOwnership);
      resetPendingOwnerButton.addEventListener('click', resetPendingOwner);
      socialGuardianRecoveryButton.addEventListener('click', socialGuardianRecovery);

      //TIMELOCK functionality Event Listeners
      queueTimeButton.addEventListener('click', checkQueueTime);
      timelockCountdownButton.addEventListener('click', calculateQueueCountdownDate);
      timelockStartQueueButton.addEventListener('click', startTimelockQueue);

      //MULTISIG functionality Event Listeners
      multiSigExpiryTimeButton.addEventListener('click', checkMultiSigExpiryTime);
      multiSigCurrentSignatureCountButton.addEventListener('click', checkMultiSigCurrentSignatureCount);
      multiSigCheckSignerButton.addEventListener('click', checkIfSignerMultiSig);
      multiSigHasSignedButton.addEventListener('click', checkIfSignedMultiSig);
      multiSigRegisterSignatureButton.addEventListener('click', multiSigRegisterSignature);

      //NFT functionality Event Listeners
      mintNFTButton.addEventListener('click', mintNFT);
      balanceOfNFTButton.addEventListener('click', checkNFTBalanceOf);
      ownerOfNFTButton.addEventListener('click', checkOwnerOfNFT);
      tokenURINFTButton.addEventListener('click', checkTokenURI);
      burnNFTButton.addEventListener('click', burnNFT);
      approveNFTButton.addEventListener('click', approveNFT);
      getApprovedNFTButton.addEventListener('click', getApprovedAddress);
      resetApprovalNFTButton.addEventListener('click', resetApproval);
      setApprovalForAllNFTButton.addEventListener('click', setApprovalForAllNFT);
      checkApprovalForAllNFTButton.addEventListener('click', checkApprovalForAllNFT);
      resetApprovalForAllNFTButton.addEventListener('click', resetApprovalAllNFT);
      transferNFTButton.addEventListener('click', transferNFT);

      //Whitelist Event Listeners
      whitelistAuctionCheckButton.addEventListener('click', isWhitelistAuction);
      whitelistAuctionParticipantCheckButton.addEventListener('click', isParticipantWhitelisted);
      configureWhitelistAuctionButton.addEventListener('click', configureAsWhitelistAuction)
      whitelistParticipantsButton.addEventListener('click', whitelistParticipants);

      //Blacklist Event Listeners
      blacklistAuctionCheckButton.addEventListener('click', isBlacklistAuction);
      blacklistAuctionParticipantCheckButton.addEventListener('click', isParticipantBlacklisted);
      configureBlacklistAuctionButton.addEventListener('click', configureAsBlacklistAuction)
      blacklistParticipantsButton.addEventListener('click', blacklistParticipants);

      //Cancellable, Cancellation Event Listeners
      cancellableAuctionCheckButton.addEventListener('click', cancellableAuctionCheck);
      cancelledAuctionCheckButton.addEventListener('click', cancelledAuctionCheck);
      configureCancellableAuctionButton.addEventListener('click', configureCancellableAuction);
      cancelAuctionButton.addEventListener('click', cancelAuction);

      //Entry fee Event Listeners
      checkAuctionEntryFeeButton.addEventListener('click', checkAuctionEntryFee);
      hasPaidEntryFeeButton.addEventListener('click', hasPaidEntryFee);
      hasWithdrawnEntryFeeButton.addEventListener('click', hasWithdrawnEntryFee);
      setEntryFeeButton.addEventListener('click', setEntryFee);

      //Auction Query Tool Event Listeners
      queryAuctionButton.addEventListener('click', queryAuction);


      //Starting Price Slider
      //Update the number input when the slider changes
      startingPriceSlider.addEventListener("input", function() {
        startingPriceInput.value = formatNumber(startingPriceSlider.value);
        startingPriceErrorSpan.textContent = ''; //Clear errors, slider guarantees correct input
      });

      //Update the slider when the number input changes
      startingPriceInput.addEventListener("input", function() {
        startingPriceSlider.value = startingPriceInput.value;
      });

      //Input validation for starting price field
      startingPriceInput.addEventListener("input", function() {
        if(isNaN(parseInt(startingPriceInput.value)) || parseInt(startingPriceInput.value) < 0 || startingPriceInput.value.length == 0 || !/^(0|[1-9]\d*)(\.\d+)?$/.test(startingPriceInput.value)) {
          startingPriceErrorSpan.textContent = 'Starting price must be at least 0!'
        } else {
          startingPriceErrorSpan.textContent = '';
        }

        if(startingPriceInput.value.trim() === "") {
          startingPriceErrorSpan.textContent = '';
        }
      });

      //Bid Increment Slider
      //Update the number input when the slider changes
      bidIncrementSlider.addEventListener("input", function() {
        bidIncrementInput.value = formatNumber(bidIncrementSlider.value);
        bidIncrementErrorSpan.textContent = ''; //Clear errors, slider guarantees correct input
      });

      //Update the slider when the number input changes
      bidIncrementInput.addEventListener("input", function() {
        bidIncrementSlider.value = bidIncrementInput.value;
      });

      //Input validation for bid increment field
      bidIncrementInput.addEventListener("input", function() {
        if(isNaN(parseInt(bidIncrementInput.value)) || parseInt(bidIncrementInput.value) < 0 || bidIncrementInput.value.length == 0 || !/^(0|[1-9]\d*)(\.\d+)?$/.test(bidIncrementInput.value)) {
          bidIncrementErrorSpan.textContent = 'Bid increment must be at least 0!'
        } else {
          bidIncrementErrorSpan.textContent = '';
        }

        if(bidIncrementInput.value.trim() === "") {
          bidIncrementErrorSpan.textContent = '';
        }
      });

      //Reserve Price Slider
      //Update the number input when the slider changes
      reservePriceSlider.addEventListener("input", function() {
        reservePriceInput.value = formatNumber(reservePriceSlider.value);
        reservePriceErrorSpan.textContent = ''; //Clear errors, slider guarantees correct input
      }) 

      //Update the slider when the number input changes
      reservePriceInput.addEventListener("input", function() {
        reservePriceSlider.value = reservePriceInput.value;
      });

      //Input validation for reserve price field
      reservePriceInput.addEventListener("input", function() {
        if(isNaN(parseInt(reservePriceInput.value)) || parseInt(reservePriceInput.value) < 0 || reservePriceInput.value.length == 0 || !/^(0|[1-9]\d*)(\.\d+)?$/.test(reservePriceInput.value)) {
          reservePriceErrorSpan.textContent = 'Reserve price must be at least 0!'
        } else {
          reservePriceErrorSpan.textContent = '';
        }

        if(reservePriceInput.value.trim() === "") {
          reservePriceErrorSpan.textContent = '';
        }
      });

      //Start block input validation on input event
      auctionStartBlockInput.addEventListener("input", async function() {
        await auctionRegistrationLatestBlockNumberDisplay();
        const latestBlockNumber = await getLatestBlockNumber();

        if(isNaN(parseInt(auctionStartBlockInput.value)) || parseInt(auctionStartBlockInput.value) <= 0 || auctionStartBlockInput.value.length == 0 || !/^\d+$/.test(auctionStartBlockInput.value)) {
          auctionStartBlockErrorSpan.textContent = 'Invalid input, must be a positive number!';
        } else if(parseInt(auctionStartBlockInput.value) < latestBlockNumber) {
          auctionStartBlockErrorSpan.textContent = 'Error: Auction cannot start at a past block!';
        } else if(parseInt(auctionEndBlockInput.value) <= parseInt(auctionStartBlockInput.value)) {
          auctionStartBlockErrorSpan.textContent = 'Start block must be less than the ending block!';
        } else {
          auctionStartBlockErrorSpan.textContent = '';
        }

        //Validation chain must be broken for correct interaction between end and start block input fields
        if(auctionEndBlockErrorSpan.textContent == 'End block must be higher than the start block!') {
          if(parseInt(auctionEndBlockInput.value) <= parseInt(auctionStartBlockInput.value)) {
            auctionEndBlockErrorSpan.textContent = 'End block must be higher than the start block!';
          } else {
            auctionEndBlockErrorSpan.textContent = '';
          }
        }

        if(auctionStartBlockInput.value.trim() === "") {
          auctionStartBlockErrorSpan.textContent = '';
        }

        //Interact with the snipe prevention interval field
        if(auctionStartBlockInput.value.trim() != '' && auctionEndBlockInput.value.trim() != '' && auctionSnipeIntervalInput.value.trim() != '') {
          if(parseInt(auctionSnipeIntervalInput.value) >= (parseInt(auctionEndBlockInput.value) - parseInt(auctionStartBlockInput.value))) {
            auctionSnipeIntervalErrorSpan.textContent = 'Interval value must be lower than the total duration of the auction';
          } else {
            auctionSnipeIntervalErrorSpan.textContent = '';
          }
        }
      });

      //End block input validation on input event
      auctionEndBlockInput.addEventListener("input", async function() {
        await auctionRegistrationLatestBlockNumberDisplay();
        const latestBlockNumber = await getLatestBlockNumber();

        if(isNaN(parseInt(auctionEndBlockInput.value)) || parseInt(auctionEndBlockInput.value) <= 0 || auctionEndBlockInput.value.length == 0 || !/^\d+$/.test(auctionEndBlockInput.value)) {
          auctionEndBlockErrorSpan.textContent = 'Invalid input, must be a positive number!';
        } else if(parseInt(auctionEndBlockInput.value) < latestBlockNumber) {
          auctionEndBlockErrorSpan.textContent = 'Error: Auction cannot end at a past block!';
        } else if(parseInt(auctionEndBlockInput.value) <= parseInt(auctionStartBlockInput.value)) {
          auctionEndBlockErrorSpan.textContent = 'End block must be higher than the start block!';
        } else {
          auctionEndBlockErrorSpan.textContent = '';
        }

        //Validation chain must be broken for correct interaction between end and start block input fields
        if(auctionStartBlockErrorSpan.textContent == 'Start block must be less than the ending block!') {
          if(parseInt(auctionEndBlockInput.value) <= parseInt(auctionStartBlockInput.value)) {
            auctionStartBlockErrorSpan.textContent = 'Start block must be less than the ending block!';
          } else {
            auctionStartBlockErrorSpan.textContent = '';
          }
        }

        if(auctionEndBlockInput.value.trim() === "") {
          auctionEndBlockErrorSpan.textContent = '';
        }

        //Interact with the snipe prevention interval field
        if(auctionStartBlockInput.value.trim() != '' && auctionEndBlockInput.value.trim() != '' && auctionSnipeIntervalInput.value.trim() != '') {
          if(parseInt(auctionSnipeIntervalInput.value) >= (parseInt(auctionEndBlockInput.value) - parseInt(auctionStartBlockInput.value))) {
            auctionSnipeIntervalErrorSpan.textContent = 'Interval value must be lower than the total duration of the auction';
          } else {
            auctionSnipeIntervalErrorSpan.textContent = '';
          }
        }
      });

      //Snipe prevention interval input validation
      auctionSnipeIntervalInput.addEventListener("input", async function() {
        if(isNaN(parseInt(auctionSnipeIntervalInput.value)) || parseInt(auctionSnipeIntervalInput.value) < 0 || auctionSnipeIntervalInput.value.length == 0 || !/^\d+$/.test(auctionSnipeIntervalInput.value)) {
          auctionSnipeIntervalErrorSpan.textContent = 'Snipe Prevention Interval must be at least 0!';
        } else if(auctionStartBlockInput.value.trim() != '' && auctionEndBlockInput.value.trim() != '') {
          if(parseInt(auctionSnipeIntervalInput.value) >= (parseInt(auctionEndBlockInput.value) - parseInt(auctionStartBlockInput.value))) {
            auctionSnipeIntervalErrorSpan.textContent = 'Interval value must be lower than the total duration of the auction';
          } else {
            auctionSnipeIntervalErrorSpan.textContent = '';
          }
        } else {
          auctionSnipeIntervalErrorSpan.textContent = '';
        }

        if(auctionSnipeIntervalInput.value.trim() === "") {
          auctionSnipeIntervalErrorSpan.textContent = '';
        }
      });

      //Snipe prevention blocks input validation
      auctionSnipeBlocksInput.addEventListener("input", async function() {
        if(isNaN(parseInt(auctionSnipeBlocksInput.value)) || parseInt(auctionSnipeBlocksInput.value) < 0 || auctionSnipeBlocksInput.value.length == 0 || !/^\d+$/.test(auctionSnipeBlocksInput.value)) {
          auctionSnipeBlocksErrorSpan.textContent = 'Snipe Prevention Block count must be at least 0!';
        } else {
          auctionSnipeBlocksErrorSpan.textContent = '';
        }

        if(auctionSnipeBlocksInput.value.trim() === "") {
          auctionSnipeBlocksErrorSpan.textContent = '';
        }
      });

      //Validate NFT contract address input
      nftContractAddressInput.addEventListener("input", async function() {
        const nftContractAddressInputTrimmed = nftContractAddressInput.value.trim();
        const nftContractAddressInputTrimmedChecksummed = toChecksumAddress(nftContractAddressInputTrimmed);

        try {
          if (!web3.utils.isAddress(nftContractAddressInputTrimmedChecksummed)) {
          nftContractAddressErrorSpan.textContent = 'Invalid address format!';
          } else {
            const code = await web3.eth.getCode(nftContractAddressInputTrimmedChecksummed);
            if (code === '0x') {
            nftContractAddressErrorSpan.textContent = 'Address does not belong to a smart contract!';
          } else {
            const contractWeb3Object = new web3.eth.Contract([{ 
              "constant": true,
              "inputs": [{ "name": "interfaceId", "type": "bytes4" }],
              "name": "supportsInterface",
              "outputs": [{ "name": "", "type": "bool" }],
              "type": "function"
            }], nftContractAddressInputTrimmedChecksummed);
            const IERC721_INTERFACE_ID = '0x80ac58cd';
            const supportsERC721 = await contractWeb3Object.methods.supportsInterface(IERC721_INTERFACE_ID).call();
            if (!supportsERC721) {
              nftContractAddressErrorSpan.textContent = 'Contract does not implement the IERC721 interface!';
            } else {
              nftContractAddressErrorSpan.textContent = '';
            }
          }
        }
        
        if(nftContractAddressInput.value.trim() === "") {
          nftContractAddressErrorSpan.textContent = '';
        }

        } catch(error) {
          if(error.message.includes('revert')) {
            console.error("Contract does not implement the IERC721 interface!");
            nftContractAddressErrorSpan.textContent = 'Contract does not implement the IERC721 interface!';
            displayError("Contract does not implement the IERC721 interface" + error.message);
          } else {
            console.error("Failed to validate NFT input address");
            nftContractAddressErrorSpan.textContent = 'Failed to validate NFT input address';
            displayError("Failed to validate NFT input address" + error.message);
          }
        }
      });

      //Validate NFT token ID input
      nftTokenIDInput.addEventListener("input", async function() {
        const nftTokenIDInputTrimmed = nftTokenIDInput.value.trim();

        try {
          if(nftContractAddressInput.value.trim() === "" || nftContractAddressErrorSpan.textContent != '') {
            nftTokenIDErrorSpan.textContent = 'Fill out the NFT Contract Address with a valid input!';
          } else if(isNaN(parseInt(nftTokenIDInputTrimmed)) || parseInt(nftTokenIDInputTrimmed) < 0 || nftTokenIDInputTrimmed.length == 0 || !/^\d+$/.test(nftTokenIDInputTrimmed)) {
            nftTokenIDErrorSpan.textContent = 'Invalid token ID!';
          } else {
            const nftContractInputWeb3Object = new web3.eth.Contract([
            {
              "constant": true,
              "inputs": [{ "name": "tokenId", "type": "uint256" }],
              "name": "ownerOf",
              "outputs": [{ "name": "", "type": "address" }],
              "type": "function"
            }
            ],  nftContractAddressInput.value.trim());

            const tokenOwner = await nftContractInputWeb3Object.methods.ownerOf(nftTokenIDInputTrimmed).call();

            if(auctionAddress != tokenOwner) {
              nftTokenIDErrorSpan.textContent = `The NFT with token ID ${nftTokenIDInputTrimmed} is not owned by the auction contract!`;
            } else {
              nftTokenIDErrorSpan.textContent = '';
            }
          }

          if(nftTokenIDInput.value.trim() === "") {
            nftTokenIDErrorSpan.textContent = '';
          }

        } catch(error) {
            console.error("Failed to validate NFT token ID or token does not exist or has been burned!");
            nftTokenIDErrorSpan.textContent = 'Failed to validate NFT token ID or token does not exist or has been burned!';
            displayError("Failed to validate NFT token ID or token does not exist or has been burned:" + error.message);
        }
      });

      //Validate auction ID input
      auctionIDInput.addEventListener("input", async function() {
        const auctionIDInputTrimmed = auctionIDInput.value.trim();

        const sha256Regex = /^[a-fA-F0-9]{64}$/;

        try {
          if(!sha256Regex.test(auctionIDInputTrimmed)) {
            auctionIDErrorSpan.textContent = 'Invalid auction ID format (SHA-256 required)!';
          } else {
            const auctionIDHex = "0x" + auctionIDInputTrimmed;
            const auctionExists = await auctionContract.methods.auctionExists(auctionIDHex).call();

            if(auctionExists) {
              auctionIDErrorSpan.textContent = `Auction already exists with the ID: ${auctionIDInputTrimmed}`;
            } else {
              auctionIDErrorSpan.textContent = '';
            }
          }

          if(auctionIDInput.value.trim() === "") {
            auctionIDErrorSpan.textContent = '';
          }
        } catch(error) {
          console.error("Failed to validate auction ID!");
          auctionIDErrorSpan.textContent = 'Failed to validate auction ID!';
          displayError("Failed to validate auction ID:" + error.message);
        }
      });

      registerAuctionButton.addEventListener('click', registerAuction);

      //Whitelist participant address textarea input validation on input event
      whitelistParticipantsInput.addEventListener('input', function () {
        let cleanInput = this.value.replace(/\s+/g, '');
          
        let addresses = cleanInput.match(/0x[a-fA-F0-9]{40}/g);
          
        if (addresses) {
          this.value = addresses.join('\n');
        } else {
          this.value = '';
        }
      });

      //Blacklist participant address textarea input validation on input event
      blacklistParticipantsInput.addEventListener('input', function () {
        let cleanInput = this.value.replace(/\s+/g, '');
          
        let addresses = cleanInput.match(/0x[a-fA-F0-9]{40}/g);
          
        if (addresses) {
          this.value = addresses.join('\n');
        } else {
          this.value = '';
        }
      });
    });

    async function connectWallet() {
      clearErrorLog();

      if (typeof window.ethereum !== 'undefined') {
        web3 = new Web3(window.ethereum);
        
        try {
          //Request account access
          await window.ethereum.request({ method: 'eth_requestAccounts' });

          //Get user accounts
          const accounts = await web3.eth.getAccounts();
          userAddress = accounts[0];

          const message = `Sign this message to verify your ownership of ${userAddress}`;
          const messageHex = web3.utils.utf8ToHex(message);

          //Request signature via MetaMask
          const signature = await window.ethereum.request({
            method: 'personal_sign',
            params: [messageHex, userAddress]
          });

          if (signature) {
            console.log('Signature:', signature);

            //Store the connected wallet address in localStorage if the signature was valid
            localStorage.setItem('connectedWallet', userAddress);

            document.getElementById('walletAddress').textContent = `Connected Wallet: ${userAddress}`;

            document.getElementById('connectButton').style.display = 'none';
            document.getElementById('disconnectButton').style.display = 'block';

            //Get the current view mode stored in localStorage
            const viewMode = localStorage.getItem('viewMode');

            document.getElementById('networkName').style.display = 'block';
            document.getElementById('walletAddress').style.display = 'block';

            //When the user connects the wallet and the signature is valid, the correct interface should be displayed based on the current value of viewMode localStorage variable
            if (viewMode === 'auction') {
              document.getElementById('adminFunctions').style.display = 'none';
              document.getElementById("auctionFunctions").style.display = 'block';
              document.getElementById('refreshButton').style.display = 'block';
              document.getElementById('metamaskHeader2').style.display = 'none';
              document.getElementById('toggleButton').style.display = 'block';
              document.getElementById('toggleButton').textContent = 'Show Admin Interface';
            } else {
              //Default to admin view if no value is stored or viewMode is 'admin'
              document.getElementById("auctionFunctions").style.display = 'none';
              document.getElementById('adminFunctions').style.display = 'block';
              document.getElementById('refreshButton').style.display = 'block';
              document.getElementById('metamaskHeader2').style.display = 'none';
              document.getElementById('toggleButton').style.display = 'block';
              document.getElementById('toggleButton').textContent = 'Show Auction Interface';
            }

            //Initialize contracts
            auctionContract = new web3.eth.Contract(auctionABI, auctionAddress);
            nftContract = new web3.eth.Contract(nftABI, nftAddress);

            //Read contract state variables after wallet signature verifications
            await getNetworkName();
            await checkPauseStatus();
            await checkCurrentOwner();
            await checkPendingOwner();
            await checkRenounceUnlockedStatus();
            await checkQueueTime();
            await calculateQueueCountdownDate();

            await checkMultiSigExpiryTime();
            await displaySigners();
            await checkMultiSigCurrentSignatureCount();
            await checkNameAndSymbol();
            await auctionRegistrationLatestBlockNumberDisplay();


          } else {
            throw new Error("Signature not received");
          }

        } catch (error) {
          console.error("Error during wallet connection or signing:", error);
          alert("There was an issue connecting to MetaMask. Please check the console for more details.");
        }

      } else {
        //MetaMask is not installed
        alert('Please install MetaMask to use this application!');
        window.open('https://metamask.io/download.html', '_blank');
      }
    }

    //Disconnect Wallet Functionality
    function disconnectWallet() {
      clearErrorLog();
      localStorage.removeItem('connectedWallet'); //Remove saved wallet address from the local storage
      document.getElementById('adminFunctions').style.display = 'none'; //Hide admin functions
      document.getElementById('auctionFunctions').style.display = 'none'; //Hide auction functions
      document.getElementById('connectButton').style.display = 'block'; //Show Connect button
      document.getElementById('disconnectButton').style.display = 'none'; //Hide Disconnect button
      document.getElementById('walletAddress').textContent = ''; //Clear wallet address
      document.getElementById('networkName').textContent = ''; //Clear network name
      document.getElementById('refreshButton').style.display = 'none'; //Hide refresh button
      document.getElementById('metamaskHeader2').style.display = 'block'; //Show metamask connect label
      document.getElementById('toggleButton').style.display = 'none'; //Hide toggle button
      console.log('Wallet disconnected');
    }

    //Checks the current emergency pause status of the system
    async function checkPauseStatus() {
      try {
        const isPaused = await auctionContract.methods.isPaused().call();
        document.getElementById('pauseStatus').textContent = isPaused ? 'Contract is paused' : 'Contract is not paused';
      } catch (error) {
        console.error("Error checking isPaused status:", error);
        displayError('Failed to check system pause status: ' + error.message);
      }
    }

    //Turns emergency pause on
    async function turnEmergencyPauseOn() {
      if (document.getElementById('pauseStatus').textContent == 'Contract is paused') {
        displayError("Emergency pause is already ON");
      } else {
        try {
          const result = await auctionContract.methods.turnEmergencyPauseOn().send({ from: userAddress });
          console.log('Emergency Pause Turned On:', result);
          //pauseFeedback_ON.textContent = 'Emergency Pause Turned ON';
          await checkPauseStatus();
          pauseFeedback_OFF.textContent = '-';
          await catchLatestEmergencyPauseONEvent();
        } catch (error) {
          console.error("Error turning on emergency pause:", error);
          //pauseFeedback_ON.textContent = 'Failed to Turn ON Emergency Pause';
          displayError('Failed to Turn ON Emergency Pause:' + error.message);
        }
      }
    }

    //Turns emergency pause off
    async function turnEmergencyPauseOff() {
      if (document.getElementById('pauseStatus').textContent == 'Contract is not paused') {
        displayError("Emergency pause is already turned OFF");
      } else {
        try {
          const result = await auctionContract.methods.turnEmergencyPauseOff().send({ from: userAddress });
          console.log('Emergency Pause Turned Off:', result);
          pauseFeedback_OFF.textContent = 'Emergency Pause Turned OFF';
          await checkPauseStatus();
          pauseFeedback_ON.textContent = '-';
          await catchLatestEmergencyPauseOFFEvent();
        } catch (error) {
          console.error("Error turning off emergency pause:", error);
          pauseFeedback_OFF.textContent = 'Failed to Turn OFF Emergency Pause';
          displayError('Failed to Turn OFF Emergency Pause:' + error.message);
        }
      }
    }

    //Check the address of the current owner
    async function checkCurrentOwner() {
      try {
        const owner = await auctionContract.methods.owner().call();
        document.getElementById('currentOwner').textContent = owner;
      } catch (error) {
        console.error("Error retrieving the current owner:", error);
        displayError("Failed to retrieve current owner: " + error.message);
      }
    }

    //Check the addres of the pending owner
    async function checkPendingOwner() {
      try {
        const pendingOwner = await auctionContract.methods.pendingOwner().call();
        document.getElementById('pendingOwner').textContent = pendingOwner;
      } catch (error) {
        console.error("Error retrieving the pending owner:", error);
        displayError("Failed to retrieve pending owner: " + error.message);
      }
    }

    //Check the unlock status of the renounce feature
    async function checkRenounceUnlockedStatus() {
      try {
        const renounceUnlockedStatus = await auctionContract.methods.renounceUnlocked().call();
        document.getElementById('renounceUnlockedStatus').textContent = renounceUnlockedStatus ? 'Renounce feature is unlocked' : 'Renounce feature is locked';
      } catch (error) {
        console.error("Error checking renounce unlock status:", error);
        displayError("Failed to check renounce unlock status: " + error.message);
      }
    }

    async function checkQueueTime() {
      try {
        const queueTime = await auctionContract.methods.getQueueTime().call();
        const queueTimeMilliseconds = queueTime * 1000; //UNIX EPOCH SECONDS * 1000 => milliseconds
        const queueTimeDate = new Date(queueTimeMilliseconds); //Convert queue time miliseconds to date format
        
        if(queueTimeDate.getFullYear() == 1970) { //Lowest year possible means that the queue was not initiated (queue time is zero ms)
          document.getElementById('queueTime').textContent = 'Queue time not initiated';
        } else {
          const formattedDate = `${queueTimeDate.getFullYear()}/${queueTimeDate.getMonth() + 1}/${queueTimeDate.getDate()} ${queueTimeDate.getHours()}:${queueTimeDate.getMinutes()}:${queueTimeDate.getSeconds()}`;
          document.getElementById('queueTime').textContent = formattedDate;
        }
      } catch (error) {
        console.error("Error retrieving the queue time:", error);
        displayError("Failed to retrieve the queue time: " + error.message);
      }
    }

    //Calculate and display the queue countdown date and time based on the start queue time and the delay
    async function calculateQueueCountdownDate() {
      try {
        const timelockCountdown = document.getElementById('timelockCountdown');
        const queueTimeText = document.getElementById('queueTime').textContent;

        if (queueTimeText == '-') {
          timelockCountdown.textContent = "Queue time not available";
        } else if(queueTimeText == 'Queue time not initiated') {
          timelockCountdown.textContent = "Queue time not initiated";
        } else {
          const queueTimeDate = new Date(queueTimeText); //To Date
          const queueTimeDateInMilliseconds = queueTimeDate.getTime(); //Date to ms
          const delayInMilliseconds = 600 * 1000; //600s = 10m
          const countdownEndMilliseconds = queueTimeDateInMilliseconds + delayInMilliseconds;
          const date = new Date(countdownEndMilliseconds);
          const formattedDate = `${date.getFullYear()}/${date.getMonth() + 1}/${date.getDate()} ${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}`;
          timelockCountdown.textContent = formattedDate;
        }
      } catch (error) {
        console.error("Error retrieving the queue time:", error);
        displayError("Failed to retrieve the queue time: " + error.message);
      }
    }

    //Starts a queue for the timelock mechanism security scheme
    async function startTimelockQueue() {
      try {
        const result = await auctionContract.methods.startQueue().send({ from: userAddress });
        console.log('Timelock queue started:', result);
        timelockStartQueue.textContent = 'Timelock queue started';
        await checkQueueTime();
        await calculateQueueCountdownDate();
        await checkMultiSigCurrentSignatureCount();
        await checkMultiSigExpiryTime();
        await displaySigners();
        await catchLatestTimelockQueueStartedEvent();
      } catch (error) {
        console.error("Error starting timelock queue:", error);
        timelockStartQueue.textContent = 'Failed to start timelock queue';
        displayError('Failed to start timelock queue: ' + error.message);
      }
    }

    //Finds the value (network name) based on the key (chainID number) and returns the network name if found in the key-value map
    function getNetworkNameFromChainId(chainId) {
      return networkMap[chainId] || 'Unknown Network';
    }

    //Fetch the network name selected from the wallet of the user based on a chainID => network name map
    async function getNetworkName() {
      try {
        const chainId = await window.ethereum.request({ method: 'eth_chainId' });
        const networkName = getNetworkNameFromChainId(chainId);
        document.getElementById('networkName').textContent = `Connected Network: ${networkName}`;
      } catch (error) {
        console.error("Failed to retrieve network name:", error);
      }
    }

    //Displays an error message in the errorlog element
    function displayError(errorMessage) {
      const errorLog = document.getElementById('errorLog');
      const errorMessages = document.getElementById('errorMessages');

      //Create a new list item for the error message
      const newError = document.createElement('li');
      newError.textContent = errorMessage;

      //Append the error to the list
      errorMessages.appendChild(newError);

      const newErrorSeparator = document.createElement('li');
      newErrorSeparator.textContent = '________________________________________________________________________'
      errorMessages.appendChild(newErrorSeparator);
      errorMessages.appendChild(document.createElement('br'));
      errorLog.style.display = 'block';
    }

    //Clears the error log
    function clearErrorLog() {
      const errorMessages = document.getElementById('errorMessages');
      errorMessages.innerHTML = '';

      const errorLog = document.getElementById('errorLog');
      errorLog.style.display = 'none';
    }

    //Check the expiry time of signatures
    async function checkMultiSigExpiryTime() {
      try {
        const sigExpiryTime = await auctionContract.methods.getSignatureExpiryTime().call();
        if (sigExpiryTime == 0) {
          document.getElementById('multiSigExpiryTime').textContent = "No signatures registered";
        } else {
          const sigExpiryDate = new Date(sigExpiryTime * 1000); //Milliseconds from Epoch seconds
          const formattedSigExpiryDate = `${sigExpiryDate.getFullYear()}/${sigExpiryDate.getMonth() + 1}/${sigExpiryDate.getDate()} ${sigExpiryDate.getHours()}:${sigExpiryDate.getMinutes()}:${sigExpiryDate.getSeconds()}`;
          document.getElementById('multiSigExpiryTime').textContent = formattedSigExpiryDate;
        }
      } catch (error) {
        console.error("Error retrieving the signature expiration time:", error);
        displayError("Failed to retrieve the signature expiration time: " + error.message);
      }
    }

    //Fetches and displays signers for the user from the multi-signature security scheme
    async function displaySigners() {
      try {
        await resetSignerList();
        const signerList = document.getElementById("signerList");

        //Create an array of promises for checking if each signer has signed
        const signerPromises = signers.map(async (signer, index) => {
          const hasSigned = await checkIfSignedMultiSigAddress(signer);
          return { signer, hasSigned, index };
        });

        //Wait for all the signer checks to complete
        const signerResults = await Promise.all(signerPromises);

        //Iterate over the results in the correct order and update the DOM
        signerResults.forEach(({ signer, hasSigned, index }) => {
          const signerItem = document.createElement("div");
          signerItem.className = "signer-item";
          signerItem.textContent = `Signer ${index + 1}: ${signer}: ` + (hasSigned ? 'HAS SIGNED' : 'HAS NOT SIGNED');

          //Set text color to red if the signer has not signed
          if (!hasSigned) {
            signerItem.style.color = 'red';
          } else {
            signerItem.style.color = 'green';
          }

          signerList.appendChild(signerItem);
        });
      } catch(error) {
        console.error("There was an error fetching the signers:", error);
        displayError("There was an error fetching the signers: " + error.message);
      }
    }

    //Function to reset the signer list
    async function resetSignerList() {
      const signerListContainer = document.getElementById('signerList');
      signerListContainer.innerHTML = '';
    }

    //Check the current number of signatures registered for the multi-signature security scheme
    async function checkMultiSigCurrentSignatureCount() {
      try {
        const currentSignatureCount = await auctionContract.methods.currentSignatureCount().call();
        if (currentSignatureCount == 0) {
          document.getElementById('multiSigCurrentSignatureCount').textContent = "No signatures registered"
        } else {
          document.getElementById('multiSigCurrentSignatureCount').textContent = currentSignatureCount;
        }
      } catch (error) {
        console.error("Error retrieving the current signature count:", error);
        displayError("Failed to retrieve the current signature count: " + error.message);
      }
    }

    //Check whether an address is a valid signer for the multi-signature security scheme signer set or not
    async function checkIfSignerMultiSig() {
      const multiSigSignerInput = document.getElementById('multiSigSignerInput');
      const multiSigCheckSigner = document.getElementById('multiSigCheckSigner');

      let signerAddress = multiSigSignerInput.value.trim();

      try {
        signerAddress = toChecksumAddress(signerAddress);
        if (web3.utils.isAddress(signerAddress)) {

          const isSigner = await auctionContract.methods.isSigner(signerAddress).call();

          multiSigCheckSigner.textContent = isSigner ? 'Address is a signer' : 'Address is not a signer';

        } else {
          multiSigCheckSigner.textContent = 'Invalid address';
        }
      } catch (error) {
        console.error("Error calling isSigner:", error);
        displayError("Failed to call isSigner: " + error.message);
      }
    }

    //Convert an address to checksum version
    function toChecksumAddress(address) {
      address = address.toLowerCase().replace('0x', '');
      const hash = web3.utils.sha3(address);
      let ret = '0x';

      for (let i = 0; i < address.length; i++) {
        if (parseInt(hash[i + 2], 16) > 7) {
          ret += address[i].toUpperCase();
        } else {
          ret += address[i];
        }
      }
      return ret;
    }

    //Check whether a signer has signed or not for the multi-signature security scheme
    async function checkIfSignedMultiSig() {
      const multiSigHasSignedInput = document.getElementById('multiSigHasSignedInput');
      const multiSigHasSigned = document.getElementById('multiSigHasSigned');

      let signerAddress = multiSigHasSignedInput.value.trim();

      try {
        signerAddress = toChecksumAddress(signerAddress);
        if (web3.utils.isAddress(signerAddress)) {
          const isSigner = await auctionContract.methods.isSigner(signerAddress).call();
          if (!isSigner) {
            multiSigHasSigned.textContent = 'Not a signer, cannot sign';
          } else {
            const hasSigned = await auctionContract.methods.hasSigned(signerAddress).call();
            multiSigHasSigned.textContent = hasSigned ? 'Signer has signed' : 'Signer has not signed';
          }
        } else {
          multiSigHasSigned.textContent = 'Invalid address';
        }
      } catch (error) {
        console.error("Error calling hasSigned:", error);
        displayError("Failed to call hasSigned: " + error.message);
      }
    }

    //Check whether an address has signed or not helper function
    async function checkIfSignedMultiSigAddress(signerAddress_) {
      let signerAddressTrimmed = signerAddress_.trim();
      let signerAddressTrimmedAndChecksummed = toChecksumAddress(signerAddressTrimmed);

      const hasSigned = await auctionContract.methods.hasSigned(signerAddressTrimmedAndChecksummed).call();

      if (hasSigned == true) {
        return true;
      } else {
        return false;
      }
    }

    //REGISTER SIGNATURE FUNCTION
    async function multiSigRegisterSignature() {
      try {
        const isSigner = await auctionContract.methods.isSigner(userAddress).call();
        if(isSigner) {
          const result = await auctionContract.methods.registerSignature().send({ from: userAddress });
          multiSigRegisterSignatureSpan.textContent = result ? 'Signature registered' : 'Signature not registered';
          console.log('Register signature:', result);
          await catchLatestSignatureRegisteredEvent();
          await checkMultiSigCurrentSignatureCount();
          await checkMultiSigExpiryTime();
          await displaySigners();
        } else {
          displayError('Not a signer');
          document.getElementById('multiSigRegisterSignatureSpan').textContent = 'Not a signer';
        }

      } catch (error) {
        console.error("Error registering signature:", error);
        multiSigRegisterSignatureSpan.textContent = 'Failed to register signature';
        displayError('Failed to register signature: ' + error.message);
      }
    }

    //Event catcher for emergency pause on
    async function catchLatestEmergencyPauseONEvent() {
      try {
        const events = await auctionContract.getPastEvents('EmergencyPauseTurnedOn', {
          fromBlock: latestBlock,
          toBlock: latestBlock * 2
        });

        if (events.length > 0) {
          events.forEach(event => {
            console.log('Event EmergencyPauseTurnedOn:', event);
            pauseFeedback_ON.textContent = 'Emergency Pause is ON (Event catched)';
            checkPauseStatus();
          });
        } else {
          console.log(`No EmergencyPauseTurnedOn events found in the latest block (${latestBlock}).`);
        }
      } catch (error) {
        console.error('Error in EmergencyPauseTurnedOn event:', error);
      }
    }

    //Event catcher for emergency pause off
    async function catchLatestEmergencyPauseOFFEvent() {
      try {

        const events = await auctionContract.getPastEvents('EmergencyPauseTurnedOff', {
          fromBlock: latestBlock,
          toBlock: latestBlock * 2
        });

        if (events.length > 0) {
          events.forEach(event => {
            console.log('Event EmergencyPauseTurnedOff:', event);
            pauseFeedback_OFF.textContent = 'Emergency Pause is OFF (Event catched)';
            checkPauseStatus();
          });
        } else {
          console.log(`No EmergencyPauseTurnedOff events found in the latest block (${latestBlock}).`);
        }
      } catch (error) {
        console.error('Error in EmergencyPauseTurnedOff event:', error);
      }
    }

    //Event catcher for signature registration
    async function catchLatestSignatureRegisteredEvent() {
      try {

        const events = await auctionContract.getPastEvents('SignatureRegistered', {
          fromBlock: latestBlock,
          toBlock: latestBlock * 2
        });

        if (events.length > 0) {
          events.forEach(event => {
            console.log('Event SignatureRegistered:', event);
            multiSigRegisterSignatureSpan.textContent = "Signature registered (Event catched)";
          });
        } else {
          console.log(`No SignatureRegistered events found in the latest block (${latestBlock}).`);
        }
      } catch (error) {
        console.error('Error in SignatureRegistered event:', error);
      }
    }

    //Event catcher for timelock queue start
    async function catchLatestTimelockQueueStartedEvent() {
      try {

        const events = await auctionContract.getPastEvents('TimelockQueueStarted', {
          fromBlock: latestBlock,
          toBlock: latestBlock * 2
        });

        if (events.length > 0) {
          events.forEach(event => {
            console.log('Event TimelockQueueStarted:', event);
            timelockStartQueue.textContent = "Timelock queue started (Event catched)";

          });
        } else {
          console.log(`No TimelockQueueStarted events found in the latest block (${latestBlock}).`);
        }
      } catch (error) {
        console.error('Error in TimelockQueueStarted event:', error);
      }
    }

    //RENOUNCE START PROCESS
    async function startRenounceProcess() {
      try {

        if(document.getElementById('renounceUnlockedStatus').textContent == 'Renounce feature is unlocked') {
          displayError('Renounce feature is unlocked already');
          startRenounceProcessSpan.textContent = 'Renounce feature is unlocked already';
        } else if(userAddress != document.getElementById('currentOwner').textContent) {
          displayError('Renounce process can only be initiated by the owner');
          startRenounceProcessSpan.textContent = 'Renounce process can only be initiated by the owner';
        } else {
          const currentSignatureCount = await auctionContract.methods.currentSignatureCount().call();
          const sigExpiryTime = await auctionContract.methods.getSignatureExpiryTime().call();
          const queueTimeSeconds = await auctionContract.methods.getQueueTime().call();
          const delaySeconds = 600;
          const queueCountdownEndMilliseconds = (queueTimeSeconds * 1000 + delaySeconds * 1000);
          const gracePeriodSeconds = 300;
          const queueCountdownGracePeriodEndMilliseconds = (queueTimeSeconds * 1000 + delaySeconds * 1000 + gracePeriodSeconds * 1000);
          if(currentSignatureCount < 5) {
            displayError('Multi signature count is below the threshold');
            startRenounceProcessSpan.textContent = 'Multi signature count is below the threshold';
          } else if((sigExpiryTime*1000) < Date.now()) {
            displayError('Mutli signature validity time has elapsed');
            startRenounceProcessSpan.textContent = 'Mutli signature validity time has elapsed';
          } else if(queueTimeSeconds == 0) {
            displayError('Timelock queue not initiated');
            startRenounceProcessSpan.textContent = 'Timelock queue not initiated';
          } else if(queueCountdownEndMilliseconds > Date.now()) {
            displayError('Timelocked, wait');
            startRenounceProcessSpan.textContent = 'Timelocked, wait';
          } else if(queueCountdownGracePeriodEndMilliseconds < Date.now()) {
            displayError('Grace period expired');
            startRenounceProcessSpan.textContent = 'Grace period expired';
          } else {
            const startRenounceProcessResult = await auctionContract.methods.startRenounceProcess().send({ from: userAddress });

            console.log('Renounce process initiation:', startRenounceProcessResult);
            startRenounceProcessSpan.textContent = startRenounceProcessResult ? 'Renounce process initiated successfully' : 'Failed to initiate renounce process';
            
            await catchLatestRenounceProcessInitiatedEvent();
            await checkRenounceUnlockedStatus();
            await checkMultiSigCurrentSignatureCount();
            await checkMultiSigExpiryTime();
            await displaySigners();
            await checkQueueTime();
            await calculateQueueCountdownDate();
          }
          }

      } catch (error) {
        console.error('Error starting renounce process:', error);
        displayError('Error starting renounce process:'+ error.message);
        startRenounceProcessSpan.textContent = 'Failed to start renounce process';
      }
    }

    //Event catcher for ownership renounce process initiation
    async function catchLatestRenounceProcessInitiatedEvent() {
      try {

        const events = await auctionContract.getPastEvents('RenounceProcessInitiated', {
          fromBlock: latestBlock,
          toBlock: latestBlock * 2
        });

        if (events.length > 0) {
          events.forEach(event => {
            console.log('Event RenounceProcessInitiated:', event);
            startRenounceProcessSpan.textContent = "Renounce process initiated successfully (Event catched)";
          });
        } else {
          console.log(`No RenounceProcessInitiated events found in the latest block (${latestBlock}).`);
        }
      } catch (error) {
        console.error('Error in RenounceProcessInitiated event:', error);
      }
    }

    function refreshButtonFunction() {
      window.location.reload();
    }

    //TERMINATE RENOUNCE PROCES
    async function terminateRenounceProcess() {
      try {
        if(userAddress != document.getElementById('currentOwner').textContent) {
          displayError('Renounce process can only be terminated by the owner');
          terminateRenounceProcessSpan.textContent = 'Renounce process can only be terminated by the owner';
        } else if( document.getElementById('renounceUnlockedStatus').textContent == 'Renounce feature is locked') {
          displayError('Renounce feature is already locked already');
          terminateRenounceProcessSpan.textContent = 'Renounce feature is locked already';
        } else {
          const terminateRenounceProcessResult = await auctionContract.methods.terminateRenounceProcess().send({ from: userAddress });

          console.log('Renounce process termination:', terminateRenounceProcessResult);
          terminateRenounceProcessSpan.textContent = terminateRenounceProcessResult ? 'Renounce process terminated successfully' : 'Failed to terminate renounce process';
          await catchLatestTerminateRenounceProcessEvent();
          await checkRenounceUnlockedStatus();
        }
      } catch(error) {
        console.error('Error terminating renounce process:', error);
        displayError('Error terminating renounce process:'+ error.message);
        terminateRenounceProcessSpan.textContent = 'Failed to terminate renounce process';
      }
    }

    //Event catcher for ownership renounce process termination
    async function catchLatestTerminateRenounceProcessEvent() {
      try {

        const events = await auctionContract.getPastEvents('RenounceProcessTerminated', {
          fromBlock: latestBlock,
          toBlock: latestBlock * 2
        });

        if (events.length > 0) {
          events.forEach(event => {
            console.log('Event RenounceProcessTerminated:', event);
            terminateRenounceProcessSpan.textContent = "Renounce process terminated successfully (Event catched)";
          });
        } else {
          console.log(`No RenounceProcessTerminated events found in the latest block (${latestBlock}).`);
        }
      } catch (error) {
        console.error('Error in RenounceProcessTerminated event: ', error);
      }
    }

    //RENOUNCE OWNERSHIP
    async function renounceOwnership() {
      try {
        if(userAddress != document.getElementById('currentOwner').textContent) {
          displayError('Only the owner can renounce ownership');
          renounceOwnershipSpan.textContent = 'Only the owner can renounce ownership';
        } else {
          const renounceOwnershipResult = await auctionContract.methods.renounceOwnership().send({ from: userAddress });
          renounceOwnershipSpan.textContent = renounceOwnershipResult ? 'Ownership renounced successfully' : 'Ownership was not renounced';
          
          if(renounceOwnershipResult) {
            await checkCurrentOwner();
            await checkPendingOwner();
            await checkRenounceUnlockedStatus();
          }
        }
      } catch(error) {
        displayError('Ownership was not renounced ' + error.message)
        console.error('Ownership was not renounced ', error)
        renounceOwnershipSpan.textContent  = 'Failed to renounce ownership';
      } 
    }

    //TRANSFER OWNERSHIP
      async function transferOwnership() {
        const inputAddressOwnerTrimmed = transferOwnershipInput.value.trim();
        const inputAddressOwnerTrimmedAndChecksummed = toChecksumAddress(inputAddressOwnerTrimmed);

        try {
          if (userAddress != document.getElementById('currentOwner').textContent) {
            displayError('Only the owner can transfer ownership');
            console.error('Only the owner can transfer ownership');
            transferOwnershipSpan.textContent = 'Only the owner can transfer ownership';
          } else {
            const currentSignatureCount = await auctionContract.methods.currentSignatureCount().call();
            const sigExpiryTime = await auctionContract.methods.getSignatureExpiryTime().call();
            const queueTimeSeconds = await auctionContract.methods.getQueueTime().call();
            const delaySeconds = 600; //10 minutes = 600 seconds
            const queueCountdownEndMilliseconds = (queueTimeSeconds * 1000 + delaySeconds * 1000);
            const gracePeriodSeconds = 300; //5 minutes = 300 seconds
            const queueCountdownGracePeriodEndMilliseconds = (queueTimeSeconds * 1000 + delaySeconds * 1000 + gracePeriodSeconds * 1000);
            if (currentSignatureCount < 5) {
              displayError('Multi signature count is below the threshold');
              transferOwnershipSpan.textContent = 'Multi signature count is below the threshold';
            } else if ((sigExpiryTime * 1000) < Date.now()) {
              displayError('Mutli signature validity time has elapsed');
              transferOwnershipSpan.textContent = 'Mutli signature validity time has elapsed';
            } else if (queueTimeSeconds == 0) {
              displayError('Timelock queue not initiated');
              transferOwnershipSpan.textContent = 'Timelock queue not initiated';
            } else if (queueCountdownEndMilliseconds > Date.now()) {
              displayError('Timelocked, wait');
              transferOwnershipSpan.textContent = 'Timelocked, wait';
            } else if (queueCountdownGracePeriodEndMilliseconds < Date.now()) {
              displayError('Grace period expired');
              transferOwnershipSpan.textContent = 'Grace period expired';
            } else {
              if (web3.utils.isAddress(inputAddressOwnerTrimmedAndChecksummed)) {
                const transferOwnershipResult = await auctionContract.methods.transferOwnership(inputAddressOwnerTrimmedAndChecksummed).send({ from: userAddress });
                transferOwnershipSpan.textContent = transferOwnershipResult ? 'Transfer ownership completed' : 'Transfer ownership failed';
                await checkPendingOwner();
                await checkCurrentOwner();
                await checkMultiSigCurrentSignatureCount();
                await checkMultiSigExpiryTime();
                await displaySigners();
                await checkQueueTime();
                await calculateQueueCountdownDate();
              } else {
                displayError('Not a valid address');
                console.error('Not a valid address');
                transferOwnershipSpan.textContent = 'Not a valid address';
              }
            }
          }
        } catch (error) {
          displayError('Failed to transfer ownership: ' + error.message);
          transferOwnershipSpan.textContent = 'Failed to transfer ownership';
          console.error('Failed to transfer ownership:', error);
        }
      }

      //ACCEPT OWNERSHIP
      async function acceptOwnership() {
        const pendingOwner = await auctionContract.methods.pendingOwner().call();
        try {
          if(pendingOwner == '0x0000000000000000000000000000000000000000') {
            displayError('There is no pending ownership transfer');
            acceptOwnershipSpan.textContent = 'There is no pending ownership transfer';
          } else if(userAddress != pendingOwner) {
            displayError('Only the pending owner can accept the ownership');
            acceptOwnershipSpan.textContent = 'Only the pending owner can accept the ownershio';
          } else {
            const acceptOwnershipResult = await auctionContract.methods.acceptOwnership().send({from: userAddress});
            acceptOwnershipSpan.textContent = acceptOwnershipResult ? 'Ownership transfer completed' : 'Ownership transfer failed';

            if(acceptOwnershipResult) {
              await checkCurrentOwner();
              await checkPendingOwner();
            }

          }
        } catch(error) {
          displayError('Failed to accept ownership: '+ error.message);
          console.error('Failed to accept ownership:', error);
        }
      }

      //RESET PENDING OWNER
      async function resetPendingOwner() {
        try {
          if(userAddress != document.getElementById('currentOwner').textContent) {
            displayError('Only the owner can reset the pending owner');
            console.error('Only the owner can reset the pending owner');
            resetPendingOwnerSpan.textContent = 'Only the owner can reset the pending owner';
          } else {
            const resetPendingOwnerResult = await auctionContract.methods.resetPendingOwner().send({from: userAddress});
            resetPendingOwnerSpan.textContent = resetPendingOwnerResult ? 'Pending owner was reset' : 'Failed to reset pending owner';

            if(resetPendingOwnerResult) {
              await checkPendingOwner();
            }
          }
        } catch(error) {
          displayError('Failed to reset pending owner: '+ error.message);
          console.error('Failed to reset pending owner:', error);
          resetPendingOwnerSpan.textContent = 'Failed to reset pending owner';
        }
      }

      //SOCIAL GUARDIAN RECOVERY
      async function socialGuardianRecovery() {

        const inputGuardianRecoveryAddress_trimmed = socialGuardianRecoveryInput.value.trim();
        const inputGuardianRecoveryAddress_trimmed_checksummed = toChecksumAddress(inputGuardianRecoveryAddress_trimmed);

        const isCallerSigner = signers.some(signer => signer.toLowerCase() === userAddress.toLowerCase());

        try {
          if (!isCallerSigner) {
            displayError('Only a signer can initiate the social guardian recovery');
            console.error('Only a signer can initiate the social guardian recovery');
            socialGuardianRecoverySpan.textContent = 'Only a signer can initiate the social guardian recovery';
          } else {
            const currentSignatureCount = await auctionContract.methods.currentSignatureCount().call();
            const sigExpiryTime = await auctionContract.methods.getSignatureExpiryTime().call();
            const queueTimeSeconds = await auctionContract.methods.getQueueTime().call();
            const delaySeconds = 600; //10 minutes = 600 seconds
            const queueCountdownEndMilliseconds = (queueTimeSeconds * 1000 + delaySeconds * 1000);
            const gracePeriodSeconds = 300; //5 minutes = 300 seconds
            const queueCountdownGracePeriodEndMilliseconds = (queueTimeSeconds * 1000 + delaySeconds * 1000 + gracePeriodSeconds * 1000);
            if (currentSignatureCount < 5) {
              displayError('Multi signature count is below the threshold');
              socialGuardianRecoverySpan.textContent = 'Multi signature count is below the threshold';
            } else if ((sigExpiryTime * 1000) < Date.now()) {
              displayError('Mutli signature validity time has elapsed');
              socialGuardianRecoverySpan.textContent = 'Mutli signature validity time has elapsed';
            } else if (queueTimeSeconds == 0) {
              displayError('Timelock queue not initiated');
              socialGuardianRecoverySpan.textContent = 'Timelock queue not initiated';
            } else if (queueCountdownEndMilliseconds > Date.now()) {
              displayError('Timelocked, wait');
              socialGuardianRecoverySpan.textContent = 'Timelocked, wait';
            } else if (queueCountdownGracePeriodEndMilliseconds < Date.now()) {
              displayError('Grace period expired');
              socialGuardianRecoverySpan.textContent = 'Grace period expired';
            } else {
              if (web3.utils.isAddress(inputGuardianRecoveryAddress_trimmed_checksummed)) {
                const socialGuardianRecoveryResult = await auctionContract.methods.socialGuardianRecovery(inputGuardianRecoveryAddress_trimmed_checksummed).send({from: userAddress });
                socialGuardianRecoverySpan.textContent = socialGuardianRecoveryResult ? 'Social Guardian Recovery Completed' : 'Social Guardian Recovery Failed';
                await checkPendingOwner();
                await checkCurrentOwner();
                await checkMultiSigCurrentSignatureCount();
                await checkMultiSigExpiryTime();
                await displaySigners();
                await checkQueueTime();
                await calculateQueueCountdownDate();
              } else {
                displayError('Not a valid address');
                console.error('Not a valid address');
                socialGuardianRecoverySpan.textContent = 'Not a valid address';
              }
            }
          }
        } catch (error) {
          displayError('Social Guardian Recovery Failed: ' + error.message);
          socialGuardianRecoverySpan.textContent = 'Social Guardian Recovery Failed';
          console.error('Social Guardian Recovery Failed:', error);
        }
      }

      //NFT mint function
      async function mintNFT() {
        try {
          const currentOwnerNFTContract = await nftContract.methods.owner().call();
          
          const auctionContractAddressTrimmed = mintNFTAddressInput.value.trim();
          const auctionContractAddressTrimmedAndChecksummed = toChecksumAddress(auctionContractAddressTrimmed);

          const nftMetadataURITrimmed = mintNFTURIInput.value.trim();

          if(userAddress != currentOwnerNFTContract) {
            displayError('Only the owner can mint an NFT');
            console.error('Only the owner can mint an NFT');
            mintNFTSpan.textContent = 'Only the owner can mint an NFT';
          } else if(!web3.utils.isAddress(auctionContractAddressTrimmedAndChecksummed)) {
            displayError('Invalid Auction Contract address format');
            console.error('Invalid Auction Contract address format');
            mintNFTSpan.textContent = 'Invalid Auction Contract address format';
          } else if(auctionContractAddressTrimmedAndChecksummed == nftContract.options.address) {
            displayError('This is the NFT contract address');
            console.error('This is the NFT contract address');
            mintNFTSpan.textContent = 'This is the NFT contract address';
          } else if(nftMetadataURITrimmed === "") {
            displayError('Missing NFT token Metadata URI');
            console.error('Missing NFT token Metadata URI');
            mintNFTSpan.textContent = 'Missing NFT token Metadata URI';
          } else {
            const mintNFTResult = await nftContract.methods.safeMint(auctionContractAddressTrimmedAndChecksummed, nftMetadataURITrimmed).send({ from: userAddress });
            
            let mintedTokenId = null;
            const transferEvent = mintNFTResult.events.Transfer;

            if (Array.isArray(transferEvent)) {
                //If Transfer event is an array, loop through it
                transferEvent.forEach(event => {
                    if (event.returnValues.to === auctionContractAddressTrimmedAndChecksummed) {
                        mintedTokenId = event.returnValues.tokenId;
                    }
                });
            } else if (transferEvent && transferEvent.returnValues) {
                //If Transfer event is a single object
                if (transferEvent.returnValues.to === auctionContractAddressTrimmedAndChecksummed) {
                    mintedTokenId = transferEvent.returnValues.tokenId;
                }
            }

            if (mintNFTResult.status) {
              console.log("NFT mint was successful");
              mintNFTSpan.textContent = `NFT minted successfully with token ID: ${mintedTokenId}`;
            }

        };

        } catch(error) {
          displayError('NFT mint failed: ' + error.message);
          mintNFTSpan.textContent = 'NFT mint failed';
          console.error('NFT mint failed:', error);
        }
      }

      //Check NFT balance of an address
      async function checkNFTBalanceOf() {
        try {
          const nftBalanceAddressTrimmed = balanceOfNFTInput.value.trim();
          const nftBalanceAddressTrimmedAndChecksummed = toChecksumAddress(nftBalanceAddressTrimmed);

          if(!web3.utils.isAddress(nftBalanceAddressTrimmedAndChecksummed)) {
            displayError('Invalid address format');
            console.error('Invalid address format');
            balanceOfNFTSpan.textContent = 'Invalid address format';
          } else {
            const nftBalanceOfAddressResult = await nftContract.methods.balanceOf(nftBalanceAddressTrimmedAndChecksummed).call({ from: userAddress });
            if(nftBalanceOfAddressResult == 0) {
              balanceOfNFTSpan.textContent = "The address doesn't hold any NFTs";
            } else {
              balanceOfNFTSpan.textContent = `NFT balance of the address: ${nftBalanceOfAddressResult}`;
            }
          }
        } catch(error) {
          displayError('NFT balance check failed: ' + error.message);
          balanceOfNFTSpan.textContent = 'NFT balance check failed';
          console.error('NFT balance check failed:', error);
        }

      }

      //Check NFT owner of a specific NFT with its ID
      async function checkOwnerOfNFT() {
        const nftIDInputValueTrimmed = ownerOfNFTInput.value.trim();

        try {
          if(isNaN(nftIDInputValueTrimmed) || parseFloat(nftIDInputValueTrimmed) < 0 || nftIDInputValueTrimmed.length == 0) {
            displayError('Invalid NFT ID number');
            console.error('Invalid NFT ID number');
            ownerOfNFTSpan.textContent = 'Invalid NFT ID number';
          } else {
            const checkOwnerOfNFTResult = await nftContract.methods.ownerOf(nftIDInputValueTrimmed).call({ from: userAddress });
            ownerOfNFTSpan.textContent = checkOwnerOfNFTResult;
          }
        } catch(error) {
          if(error.message.includes('revert')) {
            console.error(`NFT (Token ID: ${nftIDInputValueTrimmed}) does not exist or has been burned`);
            ownerOfNFTSpan.textContent = `NFT (Token ID: ${nftIDInputValueTrimmed}) does not exist or has been burned`;
            displayError(`NFT (Token ID: ${nftIDInputValueTrimmed}) does not exist or has been burned` + error.message);
          } else {
            displayError('NFT owner check failed: ' + error.message);
            ownerOfNFTSpan.textContent = 'NFT owner check failed';
            console.error('NFT owner check failed:', error);
          }
        }
      }

      //Check the URI Metadata of a specific NFT with its ID
      async function checkTokenURI() {
        const tokenURIInputTrimmed = tokenURINFTInput.value.trim();

        try {
          if(isNaN(tokenURIInputTrimmed) || parseFloat(tokenURIInputTrimmed) < 0 || tokenURIInputTrimmed.length == 0) {
            displayError('Invalid NFT ID number');
            console.error('Invalid NFT ID number');
            tokenURINFTSpan.textContent = 'Invalid NFT ID number';
          } else {
            const checkTokenURIResult = await nftContract.methods.tokenURI(tokenURIInputTrimmed).call({ from: userAddress });
            tokenURINFTSpan.textContent = checkTokenURIResult;
          }
        } catch(error) {
          if(error.message.includes('revert')) {
            console.error(`NFT (Token ID: ${tokenURIInputTrimmed}) does not exist or has been burned`);
            tokenURINFTSpan.textContent = `NFT (Token ID: ${tokenURIInputTrimmed}) does not exist or has been burned`;
            displayError(`NFT (Token ID: ${tokenURIInputTrimmed}) does not exist or has been burned` + error.message);
          } else {
            displayError('NFT URI metadata check failed: ' + error.message);
            tokenURINFTSpan.textContent = 'NFT URI metadata check failed';
            console.error('NFT URI metadata check failed:', error);
          }
        }

      }
      
      //Check the NFT collection's NAME and SYMBOL values
      async function checkNameAndSymbol() {
      try {
        const fetchCollectionNameResult = await nftContract.methods.name().call();
        nftCollectionNameSpan.textContent = fetchCollectionNameResult;

        const fetchCollectionSymbolResult = await nftContract.methods.symbol().call();
        nftCollectionSymbolSpan.textContent = fetchCollectionSymbolResult;

      } catch(error) {
        displayError('Failed to retrieve the name and symbol of the NFT collection: ' + error.message);
        nftCollectionNameSpan.textContent = 'Failed to retrieve the name of the NFT collection';
        nftCollectionSymbolSpan.textContent = 'Failed to retrieve the symbol of the NFT collection';
        console.error('Failed to retrieve the name and symbol of the NFT collection:', error);
      }

      }
      
      //Burn NFT function
      async function burnNFT() {
        const nftIDInputValueTrimmed = burnNFTInput.value.trim();
        
        let tokenExists = null;

        try {
          if(isNaN(nftIDInputValueTrimmed) || parseFloat(nftIDInputValueTrimmed) < 0 || nftIDInputValueTrimmed.length == 0) {
            displayError('Invalid NFT ID number');
            console.error('Invalid NFT ID number');
            burnNFTSpan.textContent = 'Invalid NFT ID number';
          } else {
            const checkOwnerOfNFTResult = await nftContract.methods.ownerOf(nftIDInputValueTrimmed).call({ from: userAddress });
            tokenExists = true;
          }
        } catch(error) {
          if(error.message.includes('revert')) {
            tokenExists = false;
            console.error(`NFT (Token ID: ${nftIDInputValueTrimmed}) does not exist or has been burned`);
            burnNFTSpan.textContent = `NFT (Token ID: ${nftIDInputValueTrimmed}) does not exist or has been burned`;
            displayError(`NFT (Token ID: ${nftIDInputValueTrimmed}) does not exist or has been burned` + error.message);
          } else {
            console.error(`Failed to burn NFT`);
            burnNFTSpan.textContent = `Failed to burn NFT`;
            displayError(`Failed to burn NFT` + error.message);
          }
        }

        if(tokenExists) {
          try {
              const burnNFTResult = await nftContract.methods.burn(nftIDInputValueTrimmed).send({ from: userAddress });
              
              if (burnNFTResult.status) {
                console.log("NFT burn was successful");
                burnNFTSpan.textContent = `NFT burned successfully with token ID: ${nftIDInputValueTrimmed}`;
              }
          } catch(error) {
            displayError('NFT burn failed: ' + error.message);
            burnNFTSpan.textContent = 'NFT burn failed';
            console.error('NFT burn failed:', error);
          }
        }
      }

      //Approve NFT function
      async function approveNFT() {
        const nftIDInputValueTrimmed = approveNFTInputID.value.trim();

        const approveAddressInputTrimmed = approveNFTInputAddress.value.trim();
        const approveAddressInputTrimmedAndChecksummed = toChecksumAddress(approveAddressInputTrimmed);

        try {
          if(isNaN(nftIDInputValueTrimmed) || parseFloat(nftIDInputValueTrimmed) < 0 || nftIDInputValueTrimmed.length == 0) {
            displayError('Invalid NFT ID number');
            console.error('Invalid NFT ID number');
            approveNFTSpan.textContent = 'Invalid NFT ID number';
          } else if(!web3.utils.isAddress(approveAddressInputTrimmedAndChecksummed)) {
            displayError('Invalid address format');
            console.error('Invalid address format');
            approveNFTSpan.textContent = 'Invalid address format';
          } else {
            const checkOwnerOfNFTResult = await nftContract.methods.ownerOf(nftIDInputValueTrimmed).call({ from: userAddress });
            const approveNFTResult = await nftContract.methods.approve(approveAddressInputTrimmedAndChecksummed, nftIDInputValueTrimmed).send({ from: userAddress });

            if (approveNFTResult.status) {
              console.log("NFT approval was successful");
              approveNFTSpan.textContent = `NFT approval granted for address: ${approveAddressInputTrimmedAndChecksummed}, to operate on NFT with the ID: ${nftIDInputValueTrimmed}`;
            }
          }
        } catch(error) {
            displayError('NFT approval failed: ' + error.message);
            approveNFTSpan.textContent = 'NFT approval failed';
            console.error('NFT approval failed:', error);
        }
      }

      //Check active approval for an NFT
      async function getApprovedAddress() {
        const nftIDInputValueTrimmed = getApprovedNFTInput.value.trim();
        
        try {
          if(isNaN(nftIDInputValueTrimmed) || parseFloat(nftIDInputValueTrimmed) < 0 || nftIDInputValueTrimmed.length == 0) {
            displayError('Invalid NFT ID number');
            console.error('Invalid NFT ID number');
            getApprovedNFTSpan.textContent = 'Invalid NFT ID number';
          } else {
              const getApprovedAddressResult = await nftContract.methods.getApproved(nftIDInputValueTrimmed).call({ from: userAddress });
              if(getApprovedAddressResult == "0x0000000000000000000000000000000000000000") {
                getApprovedNFTSpan.textContent = `There is no active approval for the NFT with token ID: ${nftIDInputValueTrimmed}`;
              } else {
                getApprovedNFTSpan.textContent = `${getApprovedAddressResult} is approved to operate on the NFT with token ID: ${nftIDInputValueTrimmed}`;
              }
            }
        } catch(error) {
          if(error.message.includes('revert')) {
            console.error(`NFT (Token ID: ${nftIDInputValueTrimmed}) does not exist or has been burned`);
            getApprovedNFTSpan.textContent = `NFT (Token ID: ${nftIDInputValueTrimmed}) does not exist or has been burned`;
            displayError(`NFT (Token ID: ${nftIDInputValueTrimmed}) does not exist or has been burned` + error.message);
          } else {
            displayError('Failed to retrieve the approval address: ' + error.message);
            getApprovedNFTSpan.textContent = 'Failed to retrieve the approval address';
            console.error('Failed to retrieve the approval address:', error);
          }
        }
      }
      
      //Reset single approval of an NFT
      async function resetApproval() {
        const nftIDInputValueTrimmed = resetApprovalNFTInput.value.trim();
        const resetToAddress = '0x0000000000000000000000000000000000000000';

        try {
          if(isNaN(nftIDInputValueTrimmed) || parseFloat(nftIDInputValueTrimmed) < 0 || nftIDInputValueTrimmed.length == 0) {
            displayError('Invalid NFT ID number');
            console.error('Invalid NFT ID number');
            resetApprovalNFTSpan.textContent = 'Invalid NFT ID number';
          } else {
            const checkOwnerOfNFTResult = await nftContract.methods.ownerOf(nftIDInputValueTrimmed).call({ from: userAddress });
            const resetApprovalResult = await nftContract.methods.approve(resetToAddress, nftIDInputValueTrimmed).send({ from: userAddress });

            if (resetApprovalResult.status) {
              console.log("NFT approval reset was successful");
              resetApprovalNFTSpan.textContent = `NFT approval reseted for NFT with the ID: ${nftIDInputValueTrimmed} (set to the zero address)`;
            }
          }
        } catch(error) {
          displayError('NFT approval reset failed: ' + error.message);
          resetApprovalNFTSpan.textContent = 'NFT approval reset failed';
          console.error('NFT approval reset failed:', error);
        }
      }

      //Set approval for all NFTs to be operated by an address
      async function setApprovalForAllNFT() {
          const approveForAllNFTsInputTrimmed = setApprovalForAllNFTInput.value.trim();
          const approveForAllNFTsInputTrimmedAndChecksummed = toChecksumAddress(approveForAllNFTsInputTrimmed);

          try {

            if(!web3.utils.isAddress(approveForAllNFTsInputTrimmedAndChecksummed)) {
              displayError('Invalid address format');
              console.error('Invalid address format');
              setApprovalForAllNFTSpan.textContent = 'Invalid address format';
            } else {
              const approveForAllNFTsResult = await nftContract.methods.setApprovalForAll(approveForAllNFTsInputTrimmedAndChecksummed, true).send({ from: userAddress });
              
              if (approveForAllNFTsResult.status) {
                console.log(`All NFTs are approved to be operated on by the address: ${approveForAllNFTsInputTrimmedAndChecksummed}`);
                setApprovalForAllNFTSpan.textContent = `All NFTs are approved to be operated on by the address: ${approveForAllNFTsInputTrimmedAndChecksummed}`;
              }
            }
          } catch(error) {
            displayError('Failed to approve all NFTs: ' + error.message);
            setApprovalForAllNFTSpan.textContent = 'Failed to approve all NFTs';
            console.error('Failed to approve all NFTs:', error);
          }
      }

      //Check whether an address has approved the specified operator address to operate on all the NFTs owner by the owner address
      async function checkApprovalForAllNFT() {
        const ownerAddressInputTrimmed = checkApprovalForAllNFTInputOwnerAddress.value.trim();
        const ownerAddressInputTrimmedAndChecksummed = toChecksumAddress(ownerAddressInputTrimmed);

        const operatorAddressInputTrimmed = checkApprovalForAllNFTInputOperatorAddress.value.trim();
        const operatorAddressInputTrimmedAndChecksummed = toChecksumAddress(operatorAddressInputTrimmed);

        try {
          if(!web3.utils.isAddress(ownerAddressInputTrimmedAndChecksummed) || !web3.utils.isAddress(operatorAddressInputTrimmedAndChecksummed)) {
            displayError('Invalid address format');
            console.error('Invalid address format');
            checkApprovalForAllNFTSpan.textContent = 'Invalid address format';
          } else {
            const checkApprovalForAllNFTResult = await nftContract.methods.isApprovedForAll(ownerAddressInputTrimmedAndChecksummed, operatorAddressInputTrimmedAndChecksummed).call({ from: userAddress });
            checkApprovalForAllNFTSpan.textContent = checkApprovalForAllNFTResult ? 
            `The operator (${operatorAddressInputTrimmedAndChecksummed}) is approved to operate on all NFTs owned by the owner (${ownerAddressInputTrimmedAndChecksummed})` :
            `The operator (${operatorAddressInputTrimmedAndChecksummed}) is NOT approved to operate on all NFTs owned by the owner (${ownerAddressInputTrimmedAndChecksummed})`;
          }
        } catch(error) {
          displayError('Failed to check approval for all NFTs: ' + error.message);
          checkApprovalForAllNFTSpan.textContent = 'Failed to check approval for all NFTs';
          console.error('Failed to check approval for all NFTs:', error);
        }
      }

      //Revoke an operator's ability to operate on all NFTs owned by the owner address
      async function resetApprovalAllNFT() {
        const operatorAddressInputTrimmed = resetApprovalForAllNFTInput.value.trim();
        const operatorAddressInputTrimmedAndChecksummed = toChecksumAddress(operatorAddressInputTrimmed);

        try {
          if(!web3.utils.isAddress(operatorAddressInputTrimmedAndChecksummed)) {
            displayError('Invalid address format');
            console.error('Invalid address format');
            resetApprovalForAllNFTSpan.textContent = 'Invalid address format';
          } else {
            const checkApprovalForAllNFTResult = await nftContract.methods.isApprovedForAll(userAddress, operatorAddressInputTrimmedAndChecksummed).call({ from: userAddress });
            
            if(checkApprovalForAllNFTResult == true) {
              const resetApprovalAllNFTResult = await nftContract.methods.setApprovalForAll(operatorAddressInputTrimmedAndChecksummed, false).send({ from: userAddress });
              if (resetApprovalAllNFTResult.status) {
                console.log(`Approval revoked for operator (${operatorAddressInputTrimmedAndChecksummed}) to operate on all NFTs owned by the owner (${userAddress})`);
                resetApprovalForAllNFTSpan.textContent = `Approval revoked for operator (${operatorAddressInputTrimmedAndChecksummed}) to operate on all NFTs owned by the owner (${userAddress})`;
              }
            } else {
              resetApprovalForAllNFTSpan.textContent = `The operator (${operatorAddressInputTrimmedAndChecksummed}) is NOT approved to operate on all NFTs owned by the owner (${userAddress})`;
            }
          }
        } catch(error) {
          displayError('Failed to revoke approval of all NFTs: ' + error.message);
          resetApprovalForAllNFTSpan.textContent = 'Failed to revoke approval of all NFTs';
          console.error('Failed to revoke approval of all NFTs:', error);
        }
      }

      //Transfer an NFT from an address to an address with token ID
      async function transferNFT() {
        const sourceAddressInputTrimmed = transferNFTInputFROM.value.trim();
        const sourceAddressInputTrimmedAndChecksummed = toChecksumAddress(sourceAddressInputTrimmed);

        const recipientAddressInputTrimmed = transferNFTInputTO.value.trim();
        const recipientAddressInputTrimmedAndChecksummed = toChecksumAddress(recipientAddressInputTrimmed);

        const nftIDInputTrimmed = transferNFTInputTokenID.value.trim();

        let tokenExists = null;

        try {
          if(!web3.utils.isAddress(sourceAddressInputTrimmedAndChecksummed) || !web3.utils.isAddress(recipientAddressInputTrimmedAndChecksummed)) {
            displayError('Invalid address format');
            console.error('Invalid address format');
            transferNFTSpan.textContent = 'Invalid address format';
          } else if(isNaN(nftIDInputTrimmed) || parseFloat(nftIDInputTrimmed) < 0 || nftIDInputTrimmed.length == 0) {
            displayError('Invalid NFT ID number');
            console.error('Invalid NFT ID number');
            transferNFTSpan.textContent = 'Invalid NFT ID number';
          } else {
            const checkOwnerOfNFTResult = await nftContract.methods.ownerOf(nftIDInputTrimmed).call({ from: userAddress });
            tokenExists = true;
          }
        } catch(error) {
          if(error.message.includes('revert')) {
            tokenExists = false;
            console.error(`NFT (Token ID: ${nftIDInputTrimmed}) does not exist or has been burned`);
            transferNFTSpan.textContent = `NFT (Token ID: ${nftIDInputTrimmed}) does not exist or has been burned`;
            displayError(`NFT (Token ID: ${nftIDInputTrimmed}) does not exist or has been burned` + error.message);
          } else {
            console.error(`Failed to transfer NFT`);
            transferNFTSpan.textContent = `Failed to transfer NFT`;
            displayError(`Failed to transfer NFT` + error.message);
          }
        }

        if(tokenExists) {
          try {
              const transferNFTResult = await nftContract.methods.safeTransferFrom(sourceAddressInputTrimmedAndChecksummed, recipientAddressInputTrimmedAndChecksummed, nftIDInputTrimmed).send({ from: userAddress });
              
              if (transferNFTResult.status) {
                console.log("NFT transfer was successful");
                transferNFTSpan.textContent = `NFT transfered successfully with token ID: ${nftIDInputTrimmed}`;
              }
          } catch(error) {
            displayError('Failed to transfer NFT: ' + error.message);
            transferNFTSpan.textContent = 'Failed to transfer NFT';
            console.error('Failed to transfer NFT:', error);
          }
        }
      }

      function formatNumber(number) {
        return Number(number).toLocaleString('fullwide', { useGrouping: false });
      }

      //Get block number from Sepolia Ethereum Testnet network (Arbitrum Sepolia inherits the block.number global variable from Ethereum Sepolia Testnet)
      async function getLatestBlockNumber() {
        try {
          //For Ethereum Sepolia Testnet network, use the the following code:
          const sepoliaProvider = new Web3(new Web3.providers.HttpProvider("https://rpc.sepolia.org"));
          const latestBlockNumber = await sepoliaProvider.eth.getBlockNumber();
          console.log("Latest Sepolia Block Number:", latestBlockNumber);
          return latestBlockNumber;

          //For non-chain specific block number fetching use the commented out code
          /*
          const latestBlockNumber = await web3.eth.getBlockNumber();
          console.log("Latest Block Number:", latestBlockNumber);
          return latestBlockNumber;
          */
        } catch (error) {
          console.error("Error fetching latest block number:", error);
        }
      }

      async function auctionRegistrationLatestBlockNumberDisplay() {
        latestBlockNumberSpan.textContent = await getLatestBlockNumber();
      }

      async function checkAuctionRegistrationParameterValidity() {
        let errorList = [];

        const inputFieldList = [
          auctionIDInput,
          auctionStartBlockInput,
          auctionEndBlockInput,
          startingPriceInput,
          bidIncrementInput,
          reservePriceInput,
          auctionSnipeIntervalInput,
          auctionSnipeBlocksInput,
          nftContractAddressInput,
          nftTokenIDInput
        ];

        const errorSpanList = [
          auctionIDErrorSpan,
          auctionStartBlockErrorSpan,
          auctionEndBlockErrorSpan,
          startingPriceErrorSpan,
          bidIncrementErrorSpan,
          reservePriceErrorSpan,
          auctionSnipeIntervalErrorSpan,
          auctionSnipeBlocksErrorSpan,
          nftContractAddressErrorSpan,
          nftTokenIDErrorSpan
        ];

        for (let i = 0; i < inputFieldList.length; i++) {
          if (inputFieldList[i].value.trim() === "" || errorSpanList[i].textContent !== "") { //If either the input field is left empty OR an error is displayed -> invalid
            errorList.push("Error or missing data at input field: " + inputFieldList[i].getAttribute("id"));
            inputFieldList[i].style.border = "1px solid red";
          } else {
            inputFieldList[i].style.border = "";
          }
        }

        if(errorList.length == 0) {
          validityCheckErrorSpan.textContent = "All inputs are valid";
          return true;
        } else {
          validityCheckErrorSpan.innerHTML = errorList.join('<br>');
          return false;
        }
      }

        //Register auction function
          async function registerAuction() {
            const validationResult = await checkAuctionRegistrationParameterValidity();

            if(validationResult) {
              try {
                const currentAuctionContractOwner = await auctionContract.methods.owner().call();
                const isPaused = await auctionContract.methods.isPaused().call();

                if (userAddress != currentAuctionContractOwner) {
                  displayError('Only the owner can create a new auction!');
                  console.error('Only the owner can create a new auction!');
                  registerAuctionErrorSpan.textContent = 'Only the owner can create a new auction!';
                } else if (isPaused) {
                  displayError('Cannot create new auction while the system is emergency paused!');
                  console.error('Cannot create new auction while the system is emergency paused!');
                  registerAuctionErrorSpan.textContent = 'Cannot create new auction while the system is emergency paused!';
                } else {
                  const auctionIDInput_ARG = "0x" + auctionIDInput.value.trim();
                  const auctionStartBlockInput_ARG = parseInt(auctionStartBlockInput.value.trim());
                  const auctionEndBlockInput_ARG = parseInt(auctionEndBlockInput.value.trim());
                  const startingPriceInput_ARG = web3.utils.toWei(startingPriceInput.value.trim(), "ether");
                  const bidIncrementInput_ARG = web3.utils.toWei(bidIncrementInput.value.trim(), "ether");
                  const reservePriceInput_ARG = web3.utils.toWei(reservePriceInput.value.trim(), "ether");
                  const auctionSnipeIntervalInput_ARG = parseInt(auctionSnipeIntervalInput.value.trim());
                  const auctionSnipeBlocksInput_ARG = parseInt(auctionSnipeBlocksInput.value.trim());
                  const nftContractAddressInput_ARG = nftContractAddressInput.value.trim();
                  const nftTokenIDInput_ARG = parseInt(nftTokenIDInput.value.trim());
                  const ipfsStringInput_ARG = ipfsStringInput.value.trim();

                  const createNewAuctionResult = await auctionContract.methods.createNewAuction(
                    auctionIDInput_ARG,
                    auctionStartBlockInput_ARG,
                    auctionEndBlockInput_ARG,
                    startingPriceInput_ARG,
                    bidIncrementInput_ARG,
                    reservePriceInput_ARG,
                    auctionSnipeIntervalInput_ARG,
                    auctionSnipeBlocksInput_ARG,
                    nftContractAddressInput_ARG,
                    nftTokenIDInput_ARG,
                    ipfsStringInput_ARG
                  ).send({ from: userAddress });

                  if (createNewAuctionResult) {
                    registerAuctionErrorSpan.innerHTML = `
                  <table>
                    <tr><th>Parameter</th><th>Value</th></tr>
                    <tr><td>Auction ID</td><td>${auctionIDInput_ARG}</td></tr>
                    <tr><td>Auction Start Block</td><td>${auctionStartBlockInput_ARG}</td></tr>
                    <tr><td>Auction End Block</td><td>${auctionEndBlockInput_ARG}</td></tr>
                    <tr><td>Starting Price (in Wei)</td><td>${startingPriceInput_ARG}</td></tr>
                    <tr><td>Bid Increment (in Wei)</td><td>${bidIncrementInput_ARG}</td></tr>
                    <tr><td>Reserve Price (in Wei)</td><td>${reservePriceInput_ARG}</td></tr>
                    <tr><td>Auction Snipe Interval</td><td>${auctionSnipeIntervalInput_ARG}</td></tr>
                    <tr><td>Auction Snipe Blocks</td><td>${auctionSnipeBlocksInput_ARG}</td></tr>
                    <tr><td>NFT Contract Address</td><td>${nftContractAddressInput_ARG}</td></tr>
                    <tr><td>NFT Token ID</td><td>${nftTokenIDInput_ARG}</td></tr>
                    <tr><td>IPFS Metadata</td><td>${ipfsStringInput_ARG}</td></tr>
                  </table>`;

                    auctionIDInput.value = '';
                    auctionStartBlockInput.value = '';
                    auctionEndBlockInput.value = '';
                    startingPriceInput.value = '';
                    bidIncrementInput.value = '';
                    reservePriceInput.value = '';
                    auctionSnipeIntervalInput.value = '';
                    auctionSnipeBlocksInput.value = '';
                    nftContractAddressInput.value = '';
                    nftTokenIDInput.value = '';
                    ipfsStringInput.value = '';
                  }
                }
              } catch (error) {
                displayError('Failed to register auction: ' + error.message);
                registerAuctionErrorSpan.textContent = 'Failed to register auction';
                console.error('Failed to register auction:', error);
              }
            } else {
              displayError('Auction creation input validation failed');
              registerAuctionErrorSpan.textContent = 'Auction creation input validation failed';
              console.error('Auction creation input validation failed');
            }
          }

      //Whitelist configuration checker
      async function isWhitelistAuction() {
        const whitelistAuctionCheckInputTrimmed = whitelistAuctionCheckInput.value.trim();
        const sha256Regex = /^[a-fA-F0-9]{64}$/;

        try {
          if(!sha256Regex.test(whitelistAuctionCheckInputTrimmed)) {
            whitelistAuctionCheckSpan.textContent = 'Invalid auction ID format (SHA-256 required)!';
          } else {
            const auctionIDHex = "0x" + whitelistAuctionCheckInputTrimmed;
            const auctionExists = await auctionContract.methods.auctionExists(auctionIDHex).call({from: userAddress});

            if(!auctionExists) {
              whitelistAuctionCheckSpan.textContent = `Auction does not exist with the specified ID`;
            } else {
              const isWhitelistedAuctionResult = await auctionContract.methods.closedAuction(auctionIDHex).call();
              if(isWhitelistedAuctionResult) {
                whitelistAuctionCheckSpan.textContent = `Auction is configured as a whitelist auction`;
              } else {
                whitelistAuctionCheckSpan.textContent = `Auction is NOT configured as a whitelist auction`;
              }
            }
          }
        } catch(error) {
          displayError('Failed to determine whitelist status: ' + error.message);
          whitelistAuctionCheckSpan.textContent = 'Failed to determine whitelist status';
          console.error('Failed to determine whitelist status:', error);
        }

        if(whitelistAuctionCheckInput.value.trim() === "") {
          whitelistAuctionCheckSpan.textContent = '-';
        }
      }

      //Whitelist participant checker
      async function isParticipantWhitelisted() {
        const whitelistAuctionParticipantCheckInputAuctionIDTrimmed = whitelistAuctionParticipantCheckInputAuctionID.value.trim();
        const sha256Regex = /^[a-fA-F0-9]{64}$/;

        const whitelistAuctionParticipantCheckInputAddressTrimmed = whitelistAuctionParticipantCheckInputAddress.value.trim();
        const whitelistAuctionParticipantCheckInputAddressTrimmedChecksummed = toChecksumAddress(whitelistAuctionParticipantCheckInputAddressTrimmed);

        try {
          if(!web3.utils.isAddress(whitelistAuctionParticipantCheckInputAddressTrimmedChecksummed)) {
            displayError('Invalid address format');
            console.error('Invalid address format');
            whitelistAuctionParticipantCheckSpan.textContent = 'Invalid address format';
          } else if(!sha256Regex.test(whitelistAuctionParticipantCheckInputAuctionIDTrimmed)) {
            displayError('Invalid auction ID format');
            console.error('Invalid auction ID format');
            whitelistAuctionParticipantCheckSpan.textContent = 'Invalid auction ID format';
          } else {
            const auctionIDHex = "0x" + whitelistAuctionParticipantCheckInputAuctionIDTrimmed;
            const auctionExists = await auctionContract.methods.auctionExists(auctionIDHex).call({from: userAddress});

            if(!auctionExists) {
              displayError('Auction does not exist with this auction ID');
              console.error('Auction does not exist with this auction ID');
              whitelistAuctionParticipantCheckSpan.textContent = 'Auction does not exist with this auction ID';
            } else {
              const isWhitelistAuctionResult = await auctionContract.methods.closedAuction(auctionIDHex).call({from: userAddress});
              
              if(isWhitelistAuctionResult) {
                const isWhitelistedParticipantResult = await auctionContract.methods.isWhitelisted(auctionIDHex, whitelistAuctionParticipantCheckInputAddressTrimmedChecksummed).call({from: userAddress});
                if(isWhitelistedParticipantResult) {
                  whitelistAuctionParticipantCheckSpan.textContent = 'Participant is whitelisted in this whitelist auction';
                } else {
                  whitelistAuctionParticipantCheckSpan.textContent = 'Participant is NOT whitelisted in this whitelist auction';
                }
              } else {
                whitelistAuctionParticipantCheckSpan.textContent = 'Auction is NOT configured as a whitelist auction';
              }
            }
          }
        } catch(error) {
          displayError('Failed to determine whitelist participant status: ' + error.message);
          whitelistAuctionParticipantCheckSpan.textContent = 'Failed to determine whitelist participant status';
          console.error('Failed to determine whitelist participant status:', error);
        }
      }

        //Configure an existing auction into a whitelist auction
        async function configureAsWhitelistAuction() {
          const configureWhitelistAuctionInputAuctionIDTrimmed = configureWhitelistAuctionInputAuctionID.value.trim();
          const sha256Regex = /^[a-fA-F0-9]{64}$/;

          try {
            if(!sha256Regex.test(configureWhitelistAuctionInputAuctionIDTrimmed)) {
            displayError('Invalid auction ID format');
            console.error('Invalid auction ID format');
            configureWhitelistAuctionSpan.textContent = 'Invalid auction ID format';
          } else {
            const auctionIDHex = "0x" + configureWhitelistAuctionInputAuctionIDTrimmed;
            const auctionExists = await auctionContract.methods.auctionExists(auctionIDHex).call({from: userAddress});

            if(!auctionExists) {
              displayError('Auction does not exist with this auction ID');
              console.error('Auction does not exist with this auction ID');
              configureWhitelistAuctionSpan.textContent = 'Auction does not exist with this auction ID';
            } else {
              const isWhitelistAuctionResult = await auctionContract.methods.closedAuction(auctionIDHex).call({from: userAddress});

              if(isWhitelistAuctionResult) {
                displayError('Already configured as a whitelist auction');
                console.error('Already configured as a whitelist auction');
                configureWhitelistAuctionSpan.textContent = 'Already configured as a whitelist auction';
              } else {
                const currentOwner = await auctionContract.methods.owner().call({from: userAddress});
                
                if(currentOwner != userAddress) {
                  displayError('Only the owner can configure an auction as a whitelist auction');
                  console.error('Only the owner can configure an auction as a whitelist auction');
                  configureWhitelistAuctionSpan.textContent = 'Only the owner can configure an auction as a whitelist auction';
                } else {
                  const isPaused = await auctionContract.methods.isPaused().call({from: userAddress});
                  
                  if(isPaused) {
                    displayError('System is emergency paused');
                    console.error('System is emergency paused');
                    configureWhitelistAuctionSpan.textContent = 'System is emergency paused';
                  } else {
                    const auctionStartBlock = await auctionContract.methods.auctionStartBlock(auctionIDHex).call({from: userAddress});
                    const latestBlockNumber = await getLatestBlockNumber();

                    if(auctionStartBlock <= latestBlockNumber) {
                      displayError('Cannot configure an auction as a whitelist auction after it has already started');
                      console.error('Cannot configure an auction as a whitelist auction after it has already started');
                      configureWhitelistAuctionSpan.textContent = 'Cannot configure an auction as a whitelist auction after it has already started';
                    } else {
                      const configureAsWhitelistAuctionResult = await auctionContract.methods.configureAsClosedAuction(auctionIDHex).send({from: userAddress});
                      
                      if(configureAsWhitelistAuctionResult) {
                        configureWhitelistAuctionSpan.textContent = `Auction was successfully configured as a whitelist auction`;
                      }
                    }
                  }
                }
              }
            }
          }
          } catch(error) {
            displayError('Failed to configure as whitelist auction: ' + error.message);
            configureWhitelistAuctionSpan.textContent = 'Failed to configure as whitelist auction';
            console.error('Failed to configure as whitelist auction:', error);
          }
        }

        //Whitelist participants
        async function whitelistParticipants() {
          const whitelistAddressInput = whitelistParticipantsInput.value;
          const whitelistAddresses = whitelistAddressInput.split('\n');

          const auctionIDInputTrimmed = whitelistParticipantsInputAuctionID.value.trim();
          const sha256Regex = /^[a-fA-F0-9]{64}$/;

          try {
            if(whitelistParticipantsInput.value.trim() === '') {
              whitelistParticipantsSpan.textContent = 'Missing participants addresses';
            } else {
              for(let i = 0; i < whitelistAddresses.length; i++) {
                const addressTrimmed = whitelistAddresses[i].trim();
                const addressTrimmedChecksummed = toChecksumAddress(addressTrimmed);
                whitelistAddresses[i] = addressTrimmedChecksummed;
              
                if(!web3.utils.isAddress(addressTrimmedChecksummed)) {
                  whitelistParticipantsSpan.textContent = 'Invalid address input';
                  return;
                }
              }

              const addressSet = new Set();
              for (let address of whitelistAddresses) {
                if (addressSet.has(address)) {
                  whitelistParticipantsSpan.textContent = 'Duplicate addresses found';
                  return;
                }
                addressSet.add(address);
              }

              if(!sha256Regex.test(auctionIDInputTrimmed)) {
                displayError('Invalid auction ID format');
                console.error('Invalid auction ID format');
                whitelistParticipantsSpan.textContent = 'Invalid auction ID format';
              } else {
                const auctionIDHex = "0x" + auctionIDInputTrimmed;
                const auctionExists = await auctionContract.methods.auctionExists(auctionIDHex).call({from: userAddress});

                if(!auctionExists) {
                  displayError('Auction does not exist with this auction ID');
                  console.error('Auction does not exist with this auction ID');
                  whitelistParticipantsSpan.textContent = 'Auction does not exist with this auction ID';
                } else {
                  const isWhitelistAuctionResult = await auctionContract.methods.closedAuction(auctionIDHex).call({from: userAddress});

                  if(!isWhitelistAuctionResult) {
                    displayError('Not a whitelist auction');
                    console.error('Not a whitelist auction');
                    whitelistParticipantsSpan.textContent = 'Not a whitelist auction';
                  } else {

                    for (let address of whitelistAddresses) {
                      const isWhitelistedParticipantResult = await auctionContract.methods.isWhitelisted(auctionIDHex, address).call({from: userAddress});
                      if(isWhitelistedParticipantResult) {
                        whitelistParticipantsSpan.textContent = 'Some of the addresses are already whitelisted';
                        return;
                      }
                    }

                    const currentOwner = await auctionContract.methods.owner().call({from: userAddress});

                    if(currentOwner != userAddress) {
                      displayError('Only the owner can whitelist participants');
                      console.error('Only the owner can whitelist participants');
                      whitelistParticipantsSpan.textContent = 'Only the owner can whitelist participants';
                    } else {
                      const isPaused = await auctionContract.methods.isPaused().call({from: userAddress});

                      if(isPaused) {
                        displayError('The system is emergency paused');
                        console.error('The system is emergency paused');
                        whitelistParticipantsSpan.textContent = 'The system is emergency paused';
                      } else {
                        const auctionStartBlock = await auctionContract.methods.auctionStartBlock(auctionIDHex).call({from: userAddress});
                        const latestBlockNumber = await getLatestBlockNumber();

                        if(auctionStartBlock <= latestBlockNumber) {
                          displayError('Cannot whitelist participants: Auction has already started');
                          console.error('Cannot whitelist participants: Auction has already started');
                          whitelistParticipantsSpan.textContent = 'Cannot whitelist participants: Auction has already started';
                        } else {
                          const whitelistParticipantsResult = await auctionContract.methods.whitelistParticipants(auctionIDHex, whitelistAddresses).send({from: userAddress});

                          if(whitelistParticipantsResult) {
                            whitelistParticipantsSpan.textContent = 'Successfully whitelisted the passed participant addresses';
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } catch(error) {
            displayError('Failed to whitelist participants: ' + error.message);
            whitelistParticipantsSpan.textContent = 'Failed to whitelist participants';
            console.error('Failed to whitelist participants:', error);
          }
        }

      //Blacklist configuration checker
      async function isBlacklistAuction() {
        const blacklistAuctionCheckInputTrimmed = blacklistAuctionCheckInput.value.trim();
        const sha256Regex = /^[a-fA-F0-9]{64}$/;

        try {
          if(!sha256Regex.test(blacklistAuctionCheckInputTrimmed)) {
            blacklistAuctionCheckSpan.textContent = 'Invalid auction ID format (SHA-256 required)!';
          } else {
            const auctionIDHex = "0x" + blacklistAuctionCheckInputTrimmed;
            const auctionExists = await auctionContract.methods.auctionExists(auctionIDHex).call({from: userAddress});

            if(!auctionExists) {
              blacklistAuctionCheckSpan.textContent = `Auction does not exist with the specified ID`;
            } else {
              const isBlacklistedAuctionResult = await auctionContract.methods.isBlacklistAuction(auctionIDHex).call();
              if(isBlacklistedAuctionResult) {
                blacklistAuctionCheckSpan.textContent = `Auction is configured as a blacklist auction`;
              } else {
                blacklistAuctionCheckSpan.textContent = `Auction is NOT configured as a blacklist auction`;
              }
            }
          }
        } catch(error) {
          displayError('Failed to determine blacklist status: ' + error.message);
          blacklistAuctionCheckSpan.textContent = 'Failed to determine blacklist status';
          console.error('Failed to determine blacklist status:', error);
        }

        if(blacklistAuctionCheckInput.value.trim() === "") {
          blacklistAuctionCheckSpan.textContent = '-';
        }
      }

      //Blacklist participant checker
      async function isParticipantBlacklisted() {
        const blacklistAuctionParticipantCheckInputAuctionIDTrimmed = blacklistAuctionParticipantCheckInputAuctionID.value.trim();
        const sha256Regex = /^[a-fA-F0-9]{64}$/;

        const blacklistAuctionParticipantCheckInputAddressTrimmed = blacklistAuctionParticipantCheckInputAddress.value.trim();
        const blacklistAuctionParticipantCheckInputAddressTrimmedChecksummed = toChecksumAddress(blacklistAuctionParticipantCheckInputAddressTrimmed);

        try {
          if(!web3.utils.isAddress(blacklistAuctionParticipantCheckInputAddressTrimmedChecksummed)) {
            displayError('Invalid address format');
            console.error('Invalid address format');
            blacklistAuctionParticipantCheckSpan.textContent = 'Invalid address format';
          } else if(!sha256Regex.test(blacklistAuctionParticipantCheckInputAuctionIDTrimmed)) {
            displayError('Invalid auction ID format');
            console.error('Invalid auction ID format');
            blacklistAuctionParticipantCheckSpan.textContent = 'Invalid auction ID format';
          } else {
            const auctionIDHex = "0x" + blacklistAuctionParticipantCheckInputAuctionIDTrimmed;
            const auctionExists = await auctionContract.methods.auctionExists(auctionIDHex).call({from: userAddress});

            if(!auctionExists) {
              displayError('Auction does not exist with this auction ID');
              console.error('Auction does not exist with this auction ID');
              blacklistAuctionParticipantCheckSpan.textContent = 'Auction does not exist with this auction ID';
            } else {
              const isBlacklistAuctionResult = await auctionContract.methods.isBlacklistAuction(auctionIDHex).call({from: userAddress});
              
              if(isBlacklistAuctionResult) {
                const isBlacklistedParticipantResult = await auctionContract.methods.isBlacklistedParticipant(auctionIDHex, blacklistAuctionParticipantCheckInputAddressTrimmedChecksummed).call({from: userAddress});
                if(isBlacklistedParticipantResult) {
                  blacklistAuctionParticipantCheckSpan.textContent = 'Participant is blacklisted in this blacklist auction';
                } else {
                  blacklistAuctionParticipantCheckSpan.textContent = 'Participant is NOT blacklisted in this blacklist auction';
                }
              } else {
                blacklistAuctionParticipantCheckSpan.textContent = 'Auction is NOT configured as a blacklist auction';
              }
            }
          }
        } catch(error) {
          displayError('Failed to determine blacklist participant status: ' + error.message);
          blacklistAuctionParticipantCheckSpan.textContent = 'Failed to determine blacklist participant status';
          console.error('Failed to determine blacklist participant status:', error);
        }
      }

        //Configure an existing auction into a blacklist auction
        async function configureAsBlacklistAuction() {
          const configureBlacklistAuctionInputAuctionIDTrimmed = configureBlacklistAuctionInputAuctionID.value.trim();
          const sha256Regex = /^[a-fA-F0-9]{64}$/;

          try {
            if(!sha256Regex.test(configureBlacklistAuctionInputAuctionIDTrimmed)) {
            displayError('Invalid auction ID format');
            console.error('Invalid auction ID format');
            configureBlacklistAuctionSpan.textContent = 'Invalid auction ID format';
          } else {
            const auctionIDHex = "0x" + configureBlacklistAuctionInputAuctionIDTrimmed;
            const auctionExists = await auctionContract.methods.auctionExists(auctionIDHex).call({from: userAddress});

            if(!auctionExists) {
              displayError('Auction does not exist with this auction ID');
              console.error('Auction does not exist with this auction ID');
              configureBlacklistAuctionSpan.textContent = 'Auction does not exist with this auction ID';
            } else {
              const isBlacklistAuctionResult = await auctionContract.methods.isBlacklistAuction(auctionIDHex).call({from: userAddress});

              if(isBlacklistAuctionResult) {
                displayError('Already configured as a blacklist auction');
                console.error('Already configured as a blacklist auction');
                configureBlacklistAuctionSpan.textContent = 'Already configured as a blacklist auction';
              } else {
                const currentOwner = await auctionContract.methods.owner().call({from: userAddress});
                
                if(currentOwner != userAddress) {
                  displayError('Only the owner can configure an auction as a blacklist auction');
                  console.error('Only the owner can configure an auction as a blacklist auction');
                  configureBlacklistAuctionSpan.textContent = 'Only the owner can configure an auction as a blacklist auction';
                } else {
                  const isPaused = await auctionContract.methods.isPaused().call({from: userAddress});
                  
                  if(isPaused) {
                    displayError('System is emergency paused');
                    console.error('System is emergency paused');
                    configureBlacklistAuctionSpan.textContent = 'System is emergency paused';
                  } else {
                    const auctionStartBlock = await auctionContract.methods.auctionStartBlock(auctionIDHex).call({from: userAddress});
                    const latestBlockNumber = await getLatestBlockNumber();

                    if(auctionStartBlock <= latestBlockNumber) {
                      displayError('Cannot configure an auction as a blacklist auction after it has already started');
                      console.error('Cannot configure an auction as a blacklist auction after it has already started');
                      configureBlacklistAuctionSpan.textContent = 'Cannot configure an auction as a blacklist auction after it has already started';
                    } else {
                      const configureAsBlacklistAuctionResult = await auctionContract.methods.configureAsBlacklistedAuction(auctionIDHex).send({from: userAddress});
                      
                      if(configureAsBlacklistAuctionResult) {
                        configureBlacklistAuctionSpan.textContent = `Auction was successfully configured as a blacklist auction`;
                      }
                    }
                  }
                }
              }
            }
          }
          } catch(error) {
            displayError('Failed to configure as blacklist auction: ' + error.message);
            configureBlacklistAuctionSpan.textContent = 'Failed to configure as blacklist auction';
            console.error('Failed to configure as blacklist auction:', error);
          }
        }

        //Blacklist participants
        async function blacklistParticipants() {
          const blacklistAddressInput = blacklistParticipantsInput.value;
          const blacklistAddresses = blacklistAddressInput.split('\n');

          const auctionIDInputTrimmed = blacklistParticipantsInputAuctionID.value.trim();
          const sha256Regex = /^[a-fA-F0-9]{64}$/;

          try {
            if(blacklistParticipantsInput.value.trim() === '') {
              blacklistParticipantsSpan.textContent = 'Missing participants addresses';
            } else {
              for(let i = 0; i < blacklistAddresses.length; i++) {
                const addressTrimmed = blacklistAddresses[i].trim();
                const addressTrimmedChecksummed = toChecksumAddress(addressTrimmed);
                blacklistAddresses[i] = addressTrimmedChecksummed;
              
                if(!web3.utils.isAddress(addressTrimmedChecksummed)) {
                  blacklistParticipantsSpan.textContent = 'Invalid address input';
                  return;
                }
              }

              const addressSet = new Set();
              for (let address of blacklistAddresses) {
                if (addressSet.has(address)) {
                  blacklistParticipantsSpan.textContent = 'Duplicate addresses found';
                  return;
                }
                addressSet.add(address);
              }

              if(!sha256Regex.test(auctionIDInputTrimmed)) {
                displayError('Invalid auction ID format');
                console.error('Invalid auction ID format');
                blacklistParticipantsSpan.textContent = 'Invalid auction ID format';
              } else {
                const auctionIDHex = "0x" + auctionIDInputTrimmed;
                const auctionExists = await auctionContract.methods.auctionExists(auctionIDHex).call({from: userAddress});

                if(!auctionExists) {
                  displayError('Auction does not exist with this auction ID');
                  console.error('Auction does not exist with this auction ID');
                  blacklistParticipantsSpan.textContent = 'Auction does not exist with this auction ID';
                } else {
                  const isBlacklistAuctionResult = await auctionContract.methods.isBlacklistAuction(auctionIDHex).call({from: userAddress});

                  if(!isBlacklistAuctionResult) {
                    displayError('Not a blacklist auction');
                    console.error('Not a blacklist auction');
                    blacklistParticipantsSpan.textContent = 'Not a blacklist auction';
                  } else {

                    for (let address of blacklistAddresses) {
                      const isBlacklistedParticipantResult = await auctionContract.methods.isBlacklistedParticipant(auctionIDHex, address).call({from: userAddress});
                      if(isBlacklistedParticipantResult) {
                        blacklistParticipantsSpan.textContent = 'Some of the addresses are already blacklisted';
                        return;
                      }
                    }

                    const currentOwner = await auctionContract.methods.owner().call({from: userAddress});

                    if(currentOwner != userAddress) {
                      displayError('Only the owner can blacklist participants');
                      console.error('Only the owner can blacklist participants');
                      blacklistParticipantsSpan.textContent = 'Only the owner can blacklist participants';
                    } else {
                      const isPaused = await auctionContract.methods.isPaused().call({from: userAddress});

                      if(isPaused) {
                        displayError('The system is emergency paused');
                        console.error('The system is emergency paused');
                        blacklistParticipantsSpan.textContent = 'The system is emergency paused';
                      } else {
                        const auctionStartBlock = await auctionContract.methods.auctionStartBlock(auctionIDHex).call({from: userAddress});
                        const latestBlockNumber = await getLatestBlockNumber();

                        if(auctionStartBlock <= latestBlockNumber) {
                          displayError('Cannot blacklist participants: Auction has already started');
                          console.error('Cannot blacklist participants: Auction has already started');
                          blacklistParticipantsSpan.textContent = 'Cannot blacklist participants: Auction has already started';
                        } else {
                          const blacklistParticipantsResult = await auctionContract.methods.blacklistParticipants(auctionIDHex, blacklistAddresses).send({from: userAddress});

                          if(blacklistParticipantsResult) {
                            blacklistParticipantsSpan.textContent = 'Successfully blacklisted the passed participant addresses';
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } catch(error) {
            displayError('Failed to blacklist participants: ' + error.message);
            blacklistParticipantsSpan.textContent = 'Failed to blacklist participants';
            console.error('Failed to blacklist participants:', error);
          }
        }

        //Cancellable auction state checker function
        async function cancellableAuctionCheck() {
          const auctionIDInputTrimmed = cancellableAuctionCheckInput.value.trim();
          const sha256Regex = /^[a-fA-F0-9]{64}$/;

          try {
            if(!sha256Regex.test(auctionIDInputTrimmed)) {
              displayError('Invalid auction ID format');
              console.error('Invalid auction ID format');
              cancellableAuctionCheckSpan.textContent = 'Invalid auction ID format';
            } else {
              const auctionIDHex = "0x" + auctionIDInputTrimmed;
              const auctionExists = await auctionContract.methods.auctionExists(auctionIDHex).call({from: userAddress});

              if(!auctionExists) {
                displayError('Auction does not exist with this auction ID');
                console.error('Auction does not exist with this auction ID');
                cancellableAuctionCheckSpan.textContent = 'Auction does not exist with this auction ID';
              } else {
                const isCancellableResult = await auctionContract.methods.isCancellable(auctionIDHex).call({from: userAddress});

                if(!isCancellableResult) {
                  displayError('Auction is NOT connfigured to be cancellable');
                  console.error('Auction is NOT connfigured to be cancellable');
                  cancellableAuctionCheckSpan.textContent = 'Auction is NOT connfigured to be cancellable';
                } else {
                  displayError('Auction is connfigured to be cancellable');
                  console.error('Auction is connfigured to be cancellable');
                  cancellableAuctionCheckSpan.textContent = 'Auction is connfigured to be cancellable';
                }
              }
            }
          } catch(error) {
            displayError('Failed to check cancellable status: ' + error.message);
            cancellableAuctionCheckSpan.textContent = 'Failed to check cancellable status';
            console.error('Failed to check cancellable status:', error);
          }
        }

        //Cancelled auction state checker function
        async function cancelledAuctionCheck() {
          const auctionIDInputTrimmed = cancelledAuctionCheckInput.value.trim();
          const sha256Regex = /^[a-fA-F0-9]{64}$/;

          try {
            if(!sha256Regex.test(auctionIDInputTrimmed)) {
              displayError('Invalid auction ID format');
              console.error('Invalid auction ID format');
              cancelledAuctionCheckSpan.textContent = 'Invalid auction ID format';
            } else {
              const auctionIDHex = "0x" + auctionIDInputTrimmed;
              const auctionExists = await auctionContract.methods.auctionExists(auctionIDHex).call({from: userAddress});

              if(!auctionExists) {
                displayError('Auction does not exist with this auction ID');
                console.error('Auction does not exist with this auction ID');
                cancelledAuctionCheckSpan.textContent = 'Auction does not exist with this auction ID';
              } else {
                const isCancelledResult = await auctionContract.methods.isCancelled(auctionIDHex).call({from: userAddress});
                const isCancellableResult = await auctionContract.methods.isCancellable(auctionIDHex).call({from: userAddress});

                if(!isCancelledResult && isCancellableResult) {
                  displayError('Auction is currently NOT cancelled, but it is cancellable');
                  console.error('Auction is currently NOT cancelled, but it is cancellable');
                  cancelledAuctionCheckSpan.textContent = 'Auction is currently NOT cancelled, but it is cancellable';
                } else if(!isCancelledResult && !isCancellableResult) {
                  displayError('Auction is NOT cancelled, and it is NOT cancellable');
                  console.error('Auction is NOT cancelled, and it is NOT cancellable');
                  cancelledAuctionCheckSpan.textContent = 'Auction is NOT cancelled, and it is NOT cancellable';
                } else if(isCancelledResult) {
                  displayError('Auction is cancelled');
                  console.error('Auction is cancelled');
                  cancelledAuctionCheckSpan.textContent = 'Auction is cancelled';
                }
              }
            }
          } catch(error) {
            displayError('Failed to check cancel status: ' + error.message);
            cancelledAuctionCheckSpan.textContent = 'Failed to check cancel status';
            console.error('Failed to check cancel status:', error);
          }
        }

        //Configure an auction as a cancellable auction
        async function configureCancellableAuction() {
          const auctionIDInputTrimmed = configureCancellableAuctionInput.value.trim();
          const sha256Regex = /^[a-fA-F0-9]{64}$/;

          try {
            if(!sha256Regex.test(auctionIDInputTrimmed)) {
              displayError('Invalid auction ID format');
              console.error('Invalid auction ID format');
              configureCancellableAuctionSpan.textContent = 'Invalid auction ID format';
            } else {
              const auctionIDHex = "0x" + auctionIDInputTrimmed;
              const auctionExists = await auctionContract.methods.auctionExists(auctionIDHex).call({from: userAddress});

              if(!auctionExists) {
                displayError('Auction does not exist with this auction ID');
                console.error('Auction does not exist with this auction ID');
                configureCancellableAuctionSpan.textContent = 'Auction does not exist with this auction ID';
              } else {
                const isCancellableResult = await auctionContract.methods.isCancellable(auctionIDHex).call({from: userAddress});

                if(isCancellableResult) {
                  displayError('Auction is already configured as a cancellable auction');
                  console.error('Auction is already configured as a cancellable auction');
                  configureCancellableAuctionSpan.textContent = 'Auction is already configured as a cancellable auction';
                } else {
                  const currentOwner = await auctionContract.methods.owner().call({from: userAddress});
                
                  if(currentOwner != userAddress) {
                    displayError('Only the owner can configure a cancellable auction');
                    console.error('Only the owner can configure a cancellable auction');
                    configureCancellableAuctionSpan.textContent = 'Only the owner can configure a cancellable auction';
                  } else {
                    const isPaused = await auctionContract.methods.isPaused().call({from: userAddress});
                    
                    if(isPaused) {
                      displayError('System is emergency paused');
                      console.error('System is emergency paused');
                      configureCancellableAuctionSpan.textContent = 'System is emergency paused';
                    } else {
                      const auctionStartBlock = await auctionContract.methods.auctionStartBlock(auctionIDHex).call({from: userAddress});
                      const latestBlockNumber = await getLatestBlockNumber();

                      if(auctionStartBlock <= latestBlockNumber) {
                        displayError('Cannot configure an auction as a cancellable auction after it has already started');
                        console.error('Cannot configure an auction as a cancellable auction after it has already started');
                        configureCancellableAuctionSpan.textContent = 'Cannot configure an auction as a cancellable auction after it has already started';
                      } else {
                        const configureAsCancellableAuctionResult = await auctionContract.methods.configureAsCancellableAuction(auctionIDHex).send({from: userAddress});
                        
                        if(configureAsCancellableAuctionResult) {
                          configureCancellableAuctionSpan.textContent = 'Successfully Configured as Cancellable Auction';
                        }
                      }
                    }
                  }
                }
              }
            }
          } catch(error) {
            displayError('Failed to configure cancellable auction: ' + error.message);
            configureCancellableAuctionSpan.textContent = 'Failed to configure cancellable auction';
            console.error('Failed to configure cancellable auction:', error);
          }

        }
      
        //Cancel a cancellable auction
        async function cancelAuction() {
          const auctionIDInputTrimmed = cancelAuctionInput.value.trim();
          const sha256Regex = /^[a-fA-F0-9]{64}$/;

          try {
            if(!sha256Regex.test(auctionIDInputTrimmed)) {
              displayError('Invalid auction ID format');
              console.error('Invalid auction ID format');
              cancelAuctionSpan.textContent = 'Invalid auction ID format';
            } else {
              const auctionIDHex = "0x" + auctionIDInputTrimmed;
              const auctionExists = await auctionContract.methods.auctionExists(auctionIDHex).call({from: userAddress});

              if(!auctionExists) {
                displayError('Auction does not exist with this auction ID');
                console.error('Auction does not exist with this auction ID');
                cancelAuctionSpan.textContent = 'Auction does not exist with this auction ID';
              } else {
                const isCancellableResult = await auctionContract.methods.isCancellable(auctionIDHex).call({from: userAddress});

                if(!isCancellableResult) {
                  displayError('This auction cannot be cancelled, it is not configured as cancellable');
                  console.error('This auction cannot be cancelled, it is not configured as cancellable');
                  cancelAuctionSpan.textContent = 'This auction cannot be cancelled, it is not configured as cancellable';
                } else {
                  const currentOwner = await auctionContract.methods.owner().call({from: userAddress});
                
                  if(currentOwner != userAddress) {
                    displayError('Only the owner can cancel an auction');
                    console.error('Only the owner can cancel an auction');
                    cancelAuctionSpan.textContent = 'Only the owner can cancel an auction';
                  } else {
                    const isPaused = await auctionContract.methods.isPaused().call({from: userAddress});
                    
                    if(isPaused) {
                      displayError('System is emergency paused');
                      console.error('System is emergency paused');
                      cancelAuctionSpan.textContent = 'System is emergency paused';
                    } else {
                      const startBlock = await auctionContract.methods.auctionStartBlock(auctionIDHex).call({from: userAddress});
                      const endBlock = await auctionContract.methods.auctionEndBlock(auctionIDHex).call({from: userAddress});
                      const latestBlockNumber = await getLatestBlockNumber();

                      if(latestBlockNumber < startBlock) {
                        displayError('Cannot cancel an auction that has not started yet');
                        console.error('Cannot cancel an auction that has not started yet');
                        cancelAuctionSpan.textContent = 'Cannot cancel an auction that has not started yet';
                      } else if(latestBlockNumber > endBlock) {
                        displayError('Cannot cancel an auction that has already ended');
                        console.error('Cannot cancel an auction that has already ended');
                        cancelAuctionSpan.textContent = 'Cannot cancel an auction that has already ended';
                      } else {
                        const isCancelledResult = await auctionContract.methods.isCancelled(auctionIDHex).call({from: userAddress});

                        if(isCancelledResult) {
                          displayError('This auction is already cancelled');
                          console.error('This auction is already cancelled');
                          cancelAuctionSpan.textContent = 'This auction is already cancelled';
                        } else {
                          const cancelAuctionResult = await auctionContract.methods.cancelAuction(auctionIDHex).send({from: userAddress});

                          if(cancelAuctionResult) {
                            cancelAuctionSpan.textContent = 'Successfully cancelled the auction';
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } catch(error) {
            displayError('Failed to cancel the auction: ' + error.message);
            cancelAuctionSpan.textContent = 'Failed to cancel the auction';
            console.error('Failed to cancel the auction:', error);
          }
        }

        //Check Entry Fee of an auction
        async function checkAuctionEntryFee() {
          const auctionIDInputTrimmed = checkAuctionEntryFeeInput.value.trim();
          const sha256Regex = /^[a-fA-F0-9]{64}$/;

          try {
            if(!sha256Regex.test(auctionIDInputTrimmed)) {
              displayError('Invalid auction ID format');
              console.error('Invalid auction ID format');
              checkAuctionEntryFeeSpan.textContent = 'Invalid auction ID format';
            } else {
              const auctionIDHex = "0x" + auctionIDInputTrimmed;
              const auctionExists = await auctionContract.methods.auctionExists(auctionIDHex).call({from: userAddress});

              if(!auctionExists) {
                displayError('Auction does not exist with this auction ID');
                console.error('Auction does not exist with this auction ID');
                checkAuctionEntryFeeSpan.textContent = 'Auction does not exist with this auction ID';
              } else {
                const getEntryFeeResult = await auctionContract.methods.getEntryFee(auctionIDHex).call({from: userAddress});

                if(getEntryFeeResult == 0) {
                  checkAuctionEntryFeeSpan.textContent = 'There is no entry fee set for this auction';
                } else {
                  const entryFeeResultInEther = web3.utils.fromWei(getEntryFeeResult, "ether");
                  checkAuctionEntryFeeSpan.textContent = entryFeeResultInEther;
                }
              }
            }
          } catch(error) {
            displayError('Failed to fetch entry fee: ' + error.message);
            checkAuctionEntryFeeSpan.textContent = 'Failed to fetch entry fee';
            console.error('Failed to fetch entry fee:', error);
          }
        }

        //Check Entry Fee Payment status for a participant
        async function hasPaidEntryFee() {
          const auctionIDInputTrimmed = hasPaidEntryFeeInputAuctionID.value.trim();
          const sha256Regex = /^[a-fA-F0-9]{64}$/;

          const addressTrimmed = hasPaidEntryFeeInputParticipantAddress.value.trim();
          const addressTrimmedCheckSummed = toChecksumAddress(addressTrimmed);

          try {
            if(!sha256Regex.test(auctionIDInputTrimmed)) {
              displayError('Invalid auction ID format');
              console.error('Invalid auction ID format');
              hasPaidEntryFeeSpan.textContent = 'Invalid auction ID format';
            } else {
              const auctionIDHex = "0x" + auctionIDInputTrimmed;
              const auctionExists = await auctionContract.methods.auctionExists(auctionIDHex).call({from: userAddress});

              if(!auctionExists) {
                displayError('Auction does not exist with this auction ID');
                console.error('Auction does not exist with this auction ID');
                hasPaidEntryFeeSpan.textContent = 'Auction does not exist with this auction ID';
              } else {
                const getEntryFeeResult = await auctionContract.methods.getEntryFee(auctionIDHex).call({from: userAddress});

                if(getEntryFeeResult == 0) {
                  displayError('There is no entry fee set for this auction');
                  console.error('There is no entry fee set for this auction');
                  hasPaidEntryFeeSpan.textContent = 'There is no entry fee set for this auction';
                } else if(!web3.utils.isAddress(addressTrimmedCheckSummed)) {
                  displayError('Invalid Address Format');
                  console.error('Invalid Address Format');
                  hasPaidEntryFeeSpan.textContent = 'Invalid Address Format';
                } else {
                  const hasPaidEntryFeeResult = await auctionContract.methods.hasPaidEntryFee(auctionIDHex, addressTrimmedCheckSummed).call({from: userAddress});

                  if(hasPaidEntryFeeResult) {
                    hasPaidEntryFeeSpan.textContent = 'Address has paid the entry fee';
                  } else {
                    hasPaidEntryFeeSpan.textContent = 'Address has NOT paid the entry fee';
                  }
                }
              }
            }
          } catch(error) {
            displayError('Failed to fetch entry fee payment status: ' + error.message);
            hasPaidEntryFeeSpan.textContent = 'Failed to fetch entry fee payment status';
            console.error('Failed to fetch entry fee payment status:', error);
          }
        }

        //Check Entry Fee Withdrawal status for a participant
        async function hasWithdrawnEntryFee() {
          const auctionIDInputTrimmed = hasWithdrawnEntryFeeInputAuctionID.value.trim();
          const sha256Regex = /^[a-fA-F0-9]{64}$/;

          const addressTrimmed = hasWithdrawnEntryFeeInputParticipantAddress.value.trim();
          const addressTrimmedCheckSummed = toChecksumAddress(addressTrimmed);

          try {
            if(!sha256Regex.test(auctionIDInputTrimmed)) {
              displayError('Invalid auction ID format');
              console.error('Invalid auction ID format');
              hasWithdrawnEntryFeeSpan.textContent = 'Invalid auction ID format';
            } else {
              const auctionIDHex = "0x" + auctionIDInputTrimmed;
              const auctionExists = await auctionContract.methods.auctionExists(auctionIDHex).call({from: userAddress});

              if(!auctionExists) {
                displayError('Auction does not exist with this auction ID');
                console.error('Auction does not exist with this auction ID');
                hasWithdrawnEntryFeeSpan.textContent = 'Auction does not exist with this auction ID';
              } else {
                const getEntryFeeResult = await auctionContract.methods.getEntryFee(auctionIDHex).call({from: userAddress});

                if(getEntryFeeResult == 0) {
                  displayError('There is no entry fee set for this auction');
                  console.error('There is no entry fee set for this auction');
                  hasWithdrawnEntryFeeSpan.textContent = 'There is no entry fee set for this auction';
                } else if(!web3.utils.isAddress(addressTrimmedCheckSummed)) {
                  displayError('Invalid Address Format');
                  console.error('Invalid Address Format');
                  hasWithdrawnEntryFeeSpan.textContent = 'Invalid Address Format';
                } else {
                  const hasWithdrawnEntryFeeResult = await auctionContract.methods.hasWithdrawnEntryFee(auctionIDHex, addressTrimmedCheckSummed).call({from: userAddress});

                  if(hasWithdrawnEntryFeeResult) {
                    hasWithdrawnEntryFeeSpan.textContent = 'Address has withdrawn the entry fee';
                  } else {
                    hasWithdrawnEntryFeeSpan.textContent = 'Address has NOT withdrawn the entry fee';
                  }
                }
              }
            }
          } catch(error) {
            displayError('Failed to fetch entry fee withdrawal status: ' + error.message);
            hasWithdrawnEntryFeeSpan.textContent = 'Failed to fetch entry fee withdrawal status';
            console.error('Failed to fetch entry fee withdrawal status:', error);
          }
        }

        //Set entry fee
        async function setEntryFee() {
          const auctionIDInputTrimmed = setEntryFeeInputAuctionID.value.trim();
          const sha256Regex = /^[a-fA-F0-9]{64}$/;
          
          let entryFeeAmountInWei = null;

          if(setEntryFeeInputEntryFeeAmountEther.value.trim() === '') {
            displayError('Missing entry fee value');
            console.error('Missing entry fee value');
            setEntryFeeSpan.textContent = 'Missing entry fee value';
            return;
          } else if(
            isNaN(parseInt(setEntryFeeInputEntryFeeAmountEther.value)) 
            || parseInt(setEntryFeeInputEntryFeeAmountEther.value) < 0 
            || setEntryFeeInputEntryFeeAmountEther.value.length == 0 
            || !/^(0|[1-9]\d*)(\.\d+)?$/.test(setEntryFeeInputEntryFeeAmountEther.value)) 
          {
            displayError('Invalid entry fee format');
            console.error('Invalid entry fee format');
            setEntryFeeSpan.textContent = 'Invalid entry fee format';
            return;
          } else {
            entryFeeAmountInWei = web3.utils.toWei(setEntryFeeInputEntryFeeAmountEther.value.trim(), "ether");
          }
          
          try {
            if(!sha256Regex.test(auctionIDInputTrimmed)) {
              displayError('Invalid auction ID format');
              console.error('Invalid auction ID format');
              setEntryFeeSpan.textContent = 'Invalid auction ID format';
            } else {
              const auctionIDHex = "0x" + auctionIDInputTrimmed;
              const auctionExists = await auctionContract.methods.auctionExists(auctionIDHex).call({from: userAddress});

              if(!auctionExists) {
                displayError('Auction does not exist with this auction ID');
                console.error('Auction does not exist with this auction ID');
                setEntryFeeSpan.textContent = 'Auction does not exist with this auction ID';
              } else if(
                isNaN(parseInt(setEntryFeeInputEntryFeeAmountEther.value)) 
                || parseInt(setEntryFeeInputEntryFeeAmountEther.value) < 0 
                || setEntryFeeInputEntryFeeAmountEther.value.length == 0 
                || !/^(0|[1-9]\d*)(\.\d+)?$/.test(setEntryFeeInputEntryFeeAmountEther.value)) 
              {
                displayError('Invalid Entry Fee Value');
                console.error('Invalid Entry Fee Value');
                setEntryFeeSpan.textContent = 'Invalid Entry Fee Value';
              } else if(entryFeeAmountInWei <= 0) {
                displayError('Entry Fee amount must be greater than 0');
                console.error('Entry Fee amount must be greater than 0');
                setEntryFeeSpan.textContent = 'Entry Fee amount must be greater than 0';
              } else {
                const currentOwner = await auctionContract.methods.owner().call({from: userAddress});
                
                if(currentOwner != userAddress) {
                  displayError('Only the owner can set the entry fee');
                  console.error('Only the owner can set the entry fee');
                  setEntryFeeSpan.textContent = 'Only the owner can set the entry fee';
                } else {
                  const isPaused = await auctionContract.methods.isPaused().call({from: userAddress});
                  
                  if(isPaused) {
                    displayError('System is emergency paused');
                    console.error('System is emergency paused');
                    setEntryFeeSpan.textContent = 'System is emergency paused';
                  } else {
                    const auctionStartBlock = await auctionContract.methods.auctionStartBlock(auctionIDHex).call({from: userAddress});
                    const latestBlockNumber = await getLatestBlockNumber();

                    if(auctionStartBlock <= latestBlockNumber) {
                      displayError('Entry fee can only be set before the auction starts');
                      console.error('Entry fee can only be set before the auction starts');
                      setEntryFeeSpan.textContent = 'Entry fee can only be set before the auction starts';
                    } else {
                      const setEntryFeeResult = await auctionContract.methods.setEntryFee(auctionIDHex, entryFeeAmountInWei).send({from: userAddress});

                      if(setEntryFeeResult) {
                        setEntryFeeSpan.textContent = 'Entry fee set successfully';
                      }
                    }
                  }
                }
              }
            }
          } catch(error) {
            displayError('Failed to set entry fee: ' + error.message);
            setEntryFeeSpan.textContent = 'Failed to set entry fee';
            console.error('Failed to set entry fee:', error);
          }
        }

        //Query Auction Tool Function
        async function queryAuction() {
          const auctionIDInputTrimmed = queryAuctionInput.value.trim();
          const sha256Regex = /^[a-fA-F0-9]{64}$/;

          try {
            if(!sha256Regex.test(auctionIDInputTrimmed)) {
              displayError('Invalid auction ID format');
              console.error('Invalid auction ID format');
              queryAuctionSpan.textContent = 'Invalid auction ID format';
            } else {
              const auctionIDHex = "0x" + auctionIDInputTrimmed;
              const auctionExists = await auctionContract.methods.auctionExists(auctionIDHex).call({from: userAddress});

              if(!auctionExists) {
                displayError('Auction does not exist with this auction ID');
                console.error('Auction does not exist with this auction ID');
                queryAuctionSpan.textContent = 'Auction does not exist with this auction ID';
              } else {
                const startBlockNumberResult = await auctionContract.methods.auctionStartBlock(auctionIDHex).call({from: userAddress});
                const endBlockNumberResult = await auctionContract.methods.auctionEndBlock(auctionIDHex).call({from: userAddress});
                const startingPriceResult = await auctionContract.methods.startingPrice(auctionIDHex).call({from: userAddress});
                const bidIncrementResult = await auctionContract.methods.bidIncrement(auctionIDHex).call({from: userAddress});
                const reservePriceResult = await auctionContract.methods.reservePrice(auctionIDHex).call({from: userAddress});
                const snipeIntervalResult = await auctionContract.methods.auctionSnipeInterval(auctionIDHex).call({from: userAddress});
                const snipeBlocksResult = await auctionContract.methods.auctionSnipeBlocks(auctionIDHex).call({from: userAddress});
                const nftContractAddressResult = await auctionContract.methods.nftContractAddress(auctionIDHex).call({from: userAddress});
                const nftTokenIDResult = await auctionContract.methods.nftTokenID(auctionIDHex).call({from: userAddress});
                const ipfsMetadataResult = await auctionContract.methods.getIPFS(auctionIDHex).call({from: userAddress});
                const whitelistAuctionResult = await auctionContract.methods.closedAuction(auctionIDHex).call({from: userAddress});
                const blacklistAuctionResult = await auctionContract.methods.isBlacklistAuction(auctionIDHex).call({from: userAddress});
                const cancellableAuctionResult = await auctionContract.methods.isCancellable(auctionIDHex).call({from: userAddress});
                const cancelledAuctionResult = await auctionContract.methods.isCancelled(auctionIDHex).call({from: userAddress});
                const entryFeeResult = await auctionContract.methods.getEntryFee(auctionIDHex).call({from: userAddress});
                const highestBidResult = await auctionContract.methods.auctionHighestBidAmount(auctionIDHex).call({from: userAddress});
                const auctionWinnerResult = await auctionContract.methods.auctionWinner(auctionIDHex).call({from: userAddress});
                const ownerWithdrawResult = await auctionContract.methods.ownerWithdrew(auctionIDHex).call({from: userAddress});

                auctionQueryResultStartBlock.textContent = startBlockNumberResult;
                auctionQueryResultEndBlock.textContent = endBlockNumberResult;
                auctionQueryResultStartingPrice.textContent = web3.utils.fromWei(startingPriceResult, "ether");
                auctionQueryResultBidIncrement.textContent = web3.utils.fromWei(bidIncrementResult, "ether");
                auctionQueryResultReservePrice.textContent = web3.utils.fromWei(reservePriceResult, "ether");
                auctionQueryResultSnipeInterval.textContent = snipeIntervalResult;
                auctionQueryResultSnipeBlocks.textContent = snipeBlocksResult;
                auctionQueryResultNFTContractAddress.textContent = nftContractAddressResult;
                auctionQueryResultNFTTokenID.textContent = nftTokenIDResult;
                auctionQueryResultIPFS.textContent = ipfsMetadataResult;

                if(whitelistAuctionResult) {
                  auctionQueryResultWhitelist.textContent = 'This is a whitelist auction';
                } else {
                  auctionQueryResultWhitelist.textContent = 'Not a whitelist auction';
                }

                if(blacklistAuctionResult) {
                  auctionQueryResultBlacklist.textContent = 'This is a blacklist auction';
                } else {
                  auctionQueryResultBlacklist.textContent = 'Not a blacklist auction';
                }

                if(cancellableAuctionResult) {
                  auctionQueryResultCancellable.textContent = 'This is a cancellable auction';
                } else {
                  auctionQueryResultCancellable.textContent = 'Not a cancellable auction';
                }

                if(cancelledAuctionResult) {
                  auctionQueryResultCancelled.textContent = 'Auction is cancelled';
                } else {
                  auctionQueryResultCancelled.textContent = 'Auction is not cancelled';
                }

                auctionQueryResultEntryFee.textContent = web3.utils.fromWei(entryFeeResult, "ether");
                auctionQueryResultHighestBid.textContent = web3.utils.fromWei(highestBidResult, "ether");
                auctionQueryResultWinnerAddress.textContent = auctionWinnerResult;
               
                if(ownerWithdrawResult) {
                  auctionQueryResultOwnerWithdraw.textContent = 'Owner has withdrawn the winning bid';
                } else {
                  auctionQueryResultOwnerWithdraw.textContent = 'Owner has not withdrawn the winning bid';
                }

                queryAuctionSpan.textContent = 'Successfully fetched auction parameters'
              }
            }
          } catch(error) {
            displayError('Failed to retrieve auction data: ' + error.message);
            queryAuctionSpan.textContent = 'Failed to retrieve auction data';
            console.error('Failed to retrieve auction data:', error);
          }
        }

  </script>
</body>
</html>